
 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |                                                                            |
 |  Copyright (C) 2012 - 2016  Clifford Wolf <clifford@clifford.at>           |
 |                                                                            |
 |  Permission to use, copy, modify, and/or distribute this software for any  |
 |  purpose with or without fee is hereby granted, provided that the above    |
 |  copyright notice and this permission notice appear in all copies.         |
 |                                                                            |
 |  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
 |  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
 |  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
 |  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
 |  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
 |  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
 |  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.7+386 (git sha1 ca2adc30, gcc 7.2.1 -march=x86-64 -mtune=generic -O2 -fstack-protector-strong -fPIC -Os)


-- Running command `read_verilog -formal ../rtl/test_UART.v ../rtl/UART.v ../rtl/Tx/TxUART.v ../rtl/Tx/PISO_shift_register.v ../rtl/Tx/baud_generator.v ../rtl/Tx/Tx_top.v ../rtl/Tx/enable_generator.v ../rtl/Tx/test_Tx_top.v ../rtl/Rx/Rx_top.v ../rtl/Rx/synchronizer.v ../rtl/Rx/RxUART.v ../rtl/Rx/sampling_strobe_generator.v ../rtl/Rx/SIPO_shift_register.v ../rtl/Rx/rx_state.v ../rtl/Rx/check_parity.v ../rtl/Rx/detect_start_bit.v' --

1. Executing Verilog-2005 frontend.
Parsing formal Verilog input from `../rtl/test_UART.v' to AST representation.
Generating RTLIL representation for module `\test_UART'.
Successfully finished Verilog frontend.

2. Executing Verilog-2005 frontend.
Parsing formal Verilog input from `../rtl/UART.v' to AST representation.
Generating RTLIL representation for module `\UART'.
Successfully finished Verilog frontend.

3. Executing Verilog-2005 frontend.
Parsing formal Verilog input from `../rtl/Tx/TxUART.v' to AST representation.
Generating RTLIL representation for module `\TxUART'.
Successfully finished Verilog frontend.

4. Executing Verilog-2005 frontend.
Parsing formal Verilog input from `../rtl/Tx/PISO_shift_register.v' to AST representation.
Generating RTLIL representation for module `\PISO_shift_register'.
Successfully finished Verilog frontend.

5. Executing Verilog-2005 frontend.
Parsing formal Verilog input from `../rtl/Tx/baud_generator.v' to AST representation.
Generating RTLIL representation for module `\baud_generator'.
Successfully finished Verilog frontend.

6. Executing Verilog-2005 frontend.
Parsing formal Verilog input from `../rtl/Tx/Tx_top.v' to AST representation.
Generating RTLIL representation for module `\Tx_top'.
Successfully finished Verilog frontend.

7. Executing Verilog-2005 frontend.
Parsing formal Verilog input from `../rtl/Tx/enable_generator.v' to AST representation.
Generating RTLIL representation for module `\enable_generator'.
Successfully finished Verilog frontend.

8. Executing Verilog-2005 frontend.
Parsing formal Verilog input from `../rtl/Tx/test_Tx_top.v' to AST representation.
Generating RTLIL representation for module `\test_Tx_top'.
Successfully finished Verilog frontend.

9. Executing Verilog-2005 frontend.
Parsing formal Verilog input from `../rtl/Rx/Rx_top.v' to AST representation.
Generating RTLIL representation for module `\Rx_top'.
Successfully finished Verilog frontend.

10. Executing Verilog-2005 frontend.
Parsing formal Verilog input from `../rtl/Rx/synchronizer.v' to AST representation.
Generating RTLIL representation for module `\synchronizer'.
Successfully finished Verilog frontend.

11. Executing Verilog-2005 frontend.
Parsing formal Verilog input from `../rtl/Rx/RxUART.v' to AST representation.
Generating RTLIL representation for module `\RxUART'.
Successfully finished Verilog frontend.

12. Executing Verilog-2005 frontend.
Parsing formal Verilog input from `../rtl/Rx/sampling_strobe_generator.v' to AST representation.
Generating RTLIL representation for module `\sampling_strobe_generator'.
Successfully finished Verilog frontend.

13. Executing Verilog-2005 frontend.
Parsing formal Verilog input from `../rtl/Rx/SIPO_shift_register.v' to AST representation.
Generating RTLIL representation for module `\SIPO_shift_register'.
Successfully finished Verilog frontend.

14. Executing Verilog-2005 frontend.
Parsing formal Verilog input from `../rtl/Rx/rx_state.v' to AST representation.
Generating RTLIL representation for module `\rx_state'.
Successfully finished Verilog frontend.

15. Executing Verilog-2005 frontend.
Parsing formal Verilog input from `../rtl/Rx/check_parity.v' to AST representation.
Generating RTLIL representation for module `\check_parity'.
Successfully finished Verilog frontend.

16. Executing Verilog-2005 frontend.
Parsing formal Verilog input from `../rtl/Rx/detect_start_bit.v' to AST representation.
Generating RTLIL representation for module `\detect_start_bit'.
Successfully finished Verilog frontend.

-- Running command `prep -top test_UART -nordff' --

17. Executing PREP pass.

17.1. Executing HIERARCHY pass (managing design hierarchy).

17.1.1. Analyzing design hierarchy..
Top module:  \test_UART
Used module:     \UART
Used module:         \Rx_top
Used module:             \check_parity
Used module:             \RxUART
Used module:                 \sampling_strobe_generator
Used module:                 \SIPO_shift_register
Used module:                 \rx_state
Used module:                 \detect_start_bit
Used module:             \synchronizer
Used module:         \Tx_top
Used module:             \baud_generator
Used module:             \TxUART

17.1.2. Analyzing design hierarchy..
Top module:  \test_UART
Used module:     \UART
Used module:         \Rx_top
Used module:             \check_parity
Used module:             \RxUART
Used module:                 \sampling_strobe_generator
Used module:                 \SIPO_shift_register
Used module:                 \rx_state
Used module:                 \detect_start_bit
Used module:             \synchronizer
Used module:         \Tx_top
Used module:             \baud_generator
Used module:             \TxUART
Removing unused module `\test_Tx_top'.
Removing unused module `\enable_generator'.
Removing unused module `\PISO_shift_register'.
Removed 3 unused modules.
Module sampling_strobe_generator directly or indirectly contains $assert cells -> setting "keep" attribute.
Module RxUART directly or indirectly contains $assert cells -> setting "keep" attribute.
Module synchronizer directly or indirectly contains $assert cells -> setting "keep" attribute.
Module Rx_top directly or indirectly contains $assert cells -> setting "keep" attribute.
Module detect_start_bit directly or indirectly contains $assert cells -> setting "keep" attribute.
Module rx_state directly or indirectly contains $assert cells -> setting "keep" attribute.
Module UART directly or indirectly contains $assert cells -> setting "keep" attribute.
Module test_UART directly or indirectly contains $assert cells -> setting "keep" attribute.

17.2. Executing PROC pass (convert processes to netlists).

17.2.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Removing empty process `TxUART.$proc$../rtl/Tx/TxUART.v:69$214'.
Cleaned up 0 empty switches.

17.2.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed a total of 0 dead cases.

17.2.3. Executing PROC_INIT pass (extract init attributes).
Found init rule in `\sampling_strobe_generator.$proc$../rtl/Rx/sampling_strobe_generator.v:34$271'.
  Set init value: $formal$../rtl/Rx/sampling_strobe_generator.v:34$259_EN = 1'0
Found init rule in `\detect_start_bit.$proc$../rtl/Rx/detect_start_bit.v:57$312'.
  Set init value: $formal$../rtl/Rx/detect_start_bit.v:57$295_EN = 1'0
Found init rule in `\detect_start_bit.$proc$../rtl/Rx/detect_start_bit.v:23$311'.
  Set init value: \start_detected = 1'0
  Set init value: \clocks_since_start_bit = 7'0000000
  Set init value: \previously_idle = 1'1
Found init rule in `\check_parity.$proc$../rtl/Rx/check_parity.v:7$294'.
  Set init value: \rx_error = 1'0
Found init rule in `\baud_generator.$proc$../rtl/Tx/baud_generator.v:19$223'.
  Set init value: \cnt = 3'000
Found init rule in `\baud_generator.$proc$../rtl/Tx/baud_generator.v:18$222'.
  Set init value: \ck_stb = 1'0
Found init rule in `\rx_state.$proc$../rtl/Rx/rx_state.v:75$289'.
  Set init value: $formal$../rtl/Rx/rx_state.v:75$274_EN = 1'0
Found init rule in `\TxUART.$proc$../rtl/Tx/TxUART.v:15$215'.
  Set init value: \serial_out = 1'1
  Set init value: \shift_reg = 11'11111111111
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:137$202'.
  Set init value: $formal$../rtl/test_UART.v:137$28_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:136$200'.
  Set init value: $formal$../rtl/test_UART.v:136$27_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:133$198'.
  Set init value: $formal$../rtl/test_UART.v:133$26_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:126$196'.
  Set init value: $formal$../rtl/test_UART.v:126$25_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:125$194'.
  Set init value: $formal$../rtl/test_UART.v:125$24_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:121$192'.
  Set init value: $formal$../rtl/test_UART.v:121$23_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:120$190'.
  Set init value: $formal$../rtl/test_UART.v:120$22_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:116$188'.
  Set init value: $formal$../rtl/test_UART.v:116$21_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:108$186'.
  Set init value: $formal$../rtl/test_UART.v:108$20_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:107$184'.
  Set init value: $formal$../rtl/test_UART.v:107$19_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:106$182'.
  Set init value: $formal$../rtl/test_UART.v:106$18_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:105$180'.
  Set init value: $formal$../rtl/test_UART.v:105$17_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:104$178'.
  Set init value: $formal$../rtl/test_UART.v:104$16_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:98$176'.
  Set init value: $formal$../rtl/test_UART.v:98$15_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:97$174'.
  Set init value: $formal$../rtl/test_UART.v:97$14_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:91$172'.
  Set init value: $formal$../rtl/test_UART.v:91$13_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:90$170'.
  Set init value: $formal$../rtl/test_UART.v:90$12_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:89$168'.
  Set init value: $formal$../rtl/test_UART.v:89$11_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:85$166'.
  Set init value: $formal$../rtl/test_UART.v:85$10_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:84$164'.
  Set init value: $formal$../rtl/test_UART.v:84$9_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:83$162'.
  Set init value: $formal$../rtl/test_UART.v:83$8_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:79$160'.
  Set init value: $formal$../rtl/test_UART.v:79$7_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:78$158'.
  Set init value: $formal$../rtl/test_UART.v:78$6_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:77$156'.
  Set init value: $formal$../rtl/test_UART.v:77$5_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:70$154'.
  Set init value: $formal$../rtl/test_UART.v:70$4_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:69$152'.
  Set init value: $formal$../rtl/test_UART.v:69$3_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:67$150'.
  Set init value: $formal$../rtl/test_UART.v:67$2_EN = 1'0
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:55$149'.
  Set init value: \cnt = 7'0000000
Found init rule in `\test_UART.$proc$../rtl/test_UART.v:54$148'.
  Set init value: \has_been_enabled = 1'0

17.2.4. Executing PROC_ARST pass (detect async resets in processes).

17.2.5. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\SIPO_shift_register.$proc$../rtl/Rx/SIPO_shift_register.v:8$273'.
     1/1: $0\received_data[7:0]
Creating decoders for process `\sampling_strobe_generator.$proc$../rtl/Rx/sampling_strobe_generator.v:34$271'.
     1/1: $0$formal$../rtl/Rx/sampling_strobe_generator.v:34$259_EN[0:0]$272
Creating decoders for process `\sampling_strobe_generator.$proc$../rtl/Rx/sampling_strobe_generator.v:32$264'.
     1/3: $0$past$../rtl/Rx/sampling_strobe_generator.v:34$258$0[0:0]$265
     2/3: $0$formal$../rtl/Rx/sampling_strobe_generator.v:34$259_EN[0:0]$267
     3/3: $0$formal$../rtl/Rx/sampling_strobe_generator.v:34$259_CHECK[0:0]$266
Creating decoders for process `\sampling_strobe_generator.$proc$../rtl/Rx/sampling_strobe_generator.v:22$262'.
     1/1: $0\sampling_strobe[0:0]
Creating decoders for process `\sampling_strobe_generator.$proc$../rtl/Rx/sampling_strobe_generator.v:14$260'.
     1/1: $0\counter[2:0]
Creating decoders for process `\synchronizer.$proc$../rtl/Rx/synchronizer.v:17$248'.
     1/6: $0$formal$../rtl/Rx/synchronizer.v:20$242_EN[0:0]$254
     2/6: $0$formal$../rtl/Rx/synchronizer.v:20$242_CHECK[0:0]$253
     3/6: $0$formal$../rtl/Rx/synchronizer.v:19$240_EN[0:0]$252
     4/6: $0$formal$../rtl/Rx/synchronizer.v:19$240_CHECK[0:0]$251
     5/6: $0$formal$../rtl/Rx/synchronizer.v:18$238_EN[0:0]$250
     6/6: $0$formal$../rtl/Rx/synchronizer.v:18$238_CHECK[0:0]$249
Creating decoders for process `\synchronizer.$proc$../rtl/Rx/synchronizer.v:8$244'.
     1/3: $0\serial_in_synced[0:0]
     2/3: $0\serial_in_reg2[0:0]
     3/3: $0\serial_in_reg[0:0]
Creating decoders for process `\detect_start_bit.$proc$../rtl/Rx/detect_start_bit.v:57$312'.
     1/1: $0$formal$../rtl/Rx/detect_start_bit.v:57$295_EN[0:0]$313
Creating decoders for process `\detect_start_bit.$proc$../rtl/Rx/detect_start_bit.v:23$311'.
     1/3: $1\clocks_since_start_bit[6:0]
     2/3: $1\previously_idle[0:0]
     3/3: $1\start_detected[0:0]
Creating decoders for process `\detect_start_bit.$proc$../rtl/Rx/detect_start_bit.v:54$303'.
     1/2: $0$formal$../rtl/Rx/detect_start_bit.v:57$295_EN[0:0]$305
     2/2: $0$formal$../rtl/Rx/detect_start_bit.v:57$295_CHECK[0:0]$304
Creating decoders for process `\detect_start_bit.$proc$../rtl/Rx/detect_start_bit.v:43$302'.
     1/1: $0\previously_idle[0:0]
Creating decoders for process `\detect_start_bit.$proc$../rtl/Rx/detect_start_bit.v:30$298'.
     1/2: $0\clocks_since_start_bit[6:0]
     2/2: $0\start_detected[0:0]
Creating decoders for process `\check_parity.$proc$../rtl/Rx/check_parity.v:7$294'.
     1/1: $1\rx_error[0:0]
Creating decoders for process `\check_parity.$proc$../rtl/Rx/check_parity.v:12$291'.
     1/3: $0\parity_value[0:0]
     2/3: $0\parity_bit[0:0]
     3/3: $0\rx_error[0:0]
Creating decoders for process `\baud_generator.$proc$../rtl/Tx/baud_generator.v:19$223'.
     1/1: $1\cnt[2:0]
Creating decoders for process `\baud_generator.$proc$../rtl/Tx/baud_generator.v:18$222'.
     1/1: $1\ck_stb[0:0]
Creating decoders for process `\baud_generator.$proc$../rtl/Tx/baud_generator.v:21$219'.
     1/2: $0\cnt[2:0]
     2/2: $0\ck_stb[0:0]
Creating decoders for process `\rx_state.$proc$../rtl/Rx/rx_state.v:75$289'.
     1/1: $0$formal$../rtl/Rx/rx_state.v:75$274_EN[0:0]$290
Creating decoders for process `\rx_state.$proc$../rtl/Rx/rx_state.v:73$284'.
     1/2: $0$formal$../rtl/Rx/rx_state.v:75$274_EN[0:0]$285
     2/2: $0$formal$../rtl/Rx/rx_state.v:75$274_CHECK[0:0]$286
Creating decoders for process `\rx_state.$proc$../rtl/Rx/rx_state.v:40$281'.
     1/1: $0\state[3:0]
Creating decoders for process `\rx_state.$proc$../rtl/Rx/rx_state.v:33$275'.
     1/3: $0\data_is_available[0:0]
     2/3: $0\is_parity_stage[0:0]
     3/3: $0\data_is_valid[0:0]
Creating decoders for process `\TxUART.$proc$../rtl/Tx/TxUART.v:15$215'.
     1/2: $1\shift_reg[10:0]
     2/2: $1\serial_out[0:0]
Creating decoders for process `\TxUART.$proc$../rtl/Tx/TxUART.v:55$208'.
     1/1: $0\o_busy[0:0]
Creating decoders for process `\TxUART.$proc$../rtl/Tx/TxUART.v:40$207'.
     1/1: $0\serial_out[0:0]
Creating decoders for process `\TxUART.$proc$../rtl/Tx/TxUART.v:21$204'.
     1/1: $0\shift_reg[10:0]
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:137$202'.
     1/1: $0$formal$../rtl/test_UART.v:137$28_EN[0:0]$203
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:136$200'.
     1/1: $0$formal$../rtl/test_UART.v:136$27_EN[0:0]$201
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:133$198'.
     1/1: $0$formal$../rtl/test_UART.v:133$26_EN[0:0]$199
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:126$196'.
     1/1: $0$formal$../rtl/test_UART.v:126$25_EN[0:0]$197
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:125$194'.
     1/1: $0$formal$../rtl/test_UART.v:125$24_EN[0:0]$195
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:121$192'.
     1/1: $0$formal$../rtl/test_UART.v:121$23_EN[0:0]$193
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:120$190'.
     1/1: $0$formal$../rtl/test_UART.v:120$22_EN[0:0]$191
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:116$188'.
     1/1: $0$formal$../rtl/test_UART.v:116$21_EN[0:0]$189
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:108$186'.
     1/1: $0$formal$../rtl/test_UART.v:108$20_EN[0:0]$187
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:107$184'.
     1/1: $0$formal$../rtl/test_UART.v:107$19_EN[0:0]$185
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:106$182'.
     1/1: $0$formal$../rtl/test_UART.v:106$18_EN[0:0]$183
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:105$180'.
     1/1: $0$formal$../rtl/test_UART.v:105$17_EN[0:0]$181
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:104$178'.
     1/1: $0$formal$../rtl/test_UART.v:104$16_EN[0:0]$179
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:98$176'.
     1/1: $0$formal$../rtl/test_UART.v:98$15_EN[0:0]$177
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:97$174'.
     1/1: $0$formal$../rtl/test_UART.v:97$14_EN[0:0]$175
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:91$172'.
     1/1: $0$formal$../rtl/test_UART.v:91$13_EN[0:0]$173
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:90$170'.
     1/1: $0$formal$../rtl/test_UART.v:90$12_EN[0:0]$171
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:89$168'.
     1/1: $0$formal$../rtl/test_UART.v:89$11_EN[0:0]$169
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:85$166'.
     1/1: $0$formal$../rtl/test_UART.v:85$10_EN[0:0]$167
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:84$164'.
     1/1: $0$formal$../rtl/test_UART.v:84$9_EN[0:0]$165
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:83$162'.
     1/1: $0$formal$../rtl/test_UART.v:83$8_EN[0:0]$163
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:79$160'.
     1/1: $0$formal$../rtl/test_UART.v:79$7_EN[0:0]$161
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:78$158'.
     1/1: $0$formal$../rtl/test_UART.v:78$6_EN[0:0]$159
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:77$156'.
     1/1: $0$formal$../rtl/test_UART.v:77$5_EN[0:0]$157
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:70$154'.
     1/1: $0$formal$../rtl/test_UART.v:70$4_EN[0:0]$155
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:69$152'.
     1/1: $0$formal$../rtl/test_UART.v:69$3_EN[0:0]$153
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:67$150'.
     1/1: $0$formal$../rtl/test_UART.v:67$2_EN[0:0]$151
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:55$149'.
     1/1: $1\cnt[6:0]
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:54$148'.
     1/1: $1\has_been_enabled[0:0]
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:131$111'.
     1/6: $0$formal$../rtl/test_UART.v:133$26_EN[0:0]$113
     2/6: $0$formal$../rtl/test_UART.v:133$26_CHECK[0:0]$112
     3/6: $0$formal$../rtl/test_UART.v:136$27_EN[0:0]$115
     4/6: $0$formal$../rtl/test_UART.v:136$27_CHECK[0:0]$114
     5/6: $0$formal$../rtl/test_UART.v:137$28_EN[0:0]$117
     6/6: $0$formal$../rtl/test_UART.v:137$28_CHECK[0:0]$116
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:113$93'.
     1/11: $0$past$../rtl/test_UART.v:120$1$0[7:0]$94
     2/11: $0$formal$../rtl/test_UART.v:116$21_EN[0:0]$96
     3/11: $0$formal$../rtl/test_UART.v:116$21_CHECK[0:0]$95
     4/11: $0$formal$../rtl/test_UART.v:120$22_EN[0:0]$98
     5/11: $0$formal$../rtl/test_UART.v:120$22_CHECK[0:0]$97
     6/11: $0$formal$../rtl/test_UART.v:121$23_EN[0:0]$100
     7/11: $0$formal$../rtl/test_UART.v:121$23_CHECK[0:0]$99
     8/11: $0$formal$../rtl/test_UART.v:125$24_EN[0:0]$102
     9/11: $0$formal$../rtl/test_UART.v:125$24_CHECK[0:0]$101
    10/11: $0$formal$../rtl/test_UART.v:126$25_EN[0:0]$104
    11/11: $0$formal$../rtl/test_UART.v:126$25_CHECK[0:0]$103
Creating decoders for process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
     1/40: $0$formal$../rtl/test_UART.v:67$2_EN[0:0]$31
     2/40: $0$formal$../rtl/test_UART.v:67$2_CHECK[0:0]$30
     3/40: $0$formal$../rtl/test_UART.v:69$3_EN[0:0]$33
     4/40: $0$formal$../rtl/test_UART.v:69$3_CHECK[0:0]$32
     5/40: $0$formal$../rtl/test_UART.v:70$4_EN[0:0]$35
     6/40: $0$formal$../rtl/test_UART.v:70$4_CHECK[0:0]$34
     7/40: $0$formal$../rtl/test_UART.v:77$5_EN[0:0]$37
     8/40: $0$formal$../rtl/test_UART.v:77$5_CHECK[0:0]$36
     9/40: $0$formal$../rtl/test_UART.v:78$6_EN[0:0]$39
    10/40: $0$formal$../rtl/test_UART.v:78$6_CHECK[0:0]$38
    11/40: $0$formal$../rtl/test_UART.v:79$7_EN[0:0]$41
    12/40: $0$formal$../rtl/test_UART.v:79$7_CHECK[0:0]$40
    13/40: $0$formal$../rtl/test_UART.v:83$8_EN[0:0]$43
    14/40: $0$formal$../rtl/test_UART.v:83$8_CHECK[0:0]$42
    15/40: $0$formal$../rtl/test_UART.v:84$9_EN[0:0]$45
    16/40: $0$formal$../rtl/test_UART.v:84$9_CHECK[0:0]$44
    17/40: $0$formal$../rtl/test_UART.v:85$10_EN[0:0]$47
    18/40: $0$formal$../rtl/test_UART.v:85$10_CHECK[0:0]$46
    19/40: $0$formal$../rtl/test_UART.v:89$11_EN[0:0]$49
    20/40: $0$formal$../rtl/test_UART.v:89$11_CHECK[0:0]$48
    21/40: $0$formal$../rtl/test_UART.v:90$12_EN[0:0]$51
    22/40: $0$formal$../rtl/test_UART.v:90$12_CHECK[0:0]$50
    23/40: $0$formal$../rtl/test_UART.v:91$13_EN[0:0]$53
    24/40: $0$formal$../rtl/test_UART.v:91$13_CHECK[0:0]$52
    25/40: $0$formal$../rtl/test_UART.v:97$14_EN[0:0]$55
    26/40: $0$formal$../rtl/test_UART.v:97$14_CHECK[0:0]$54
    27/40: $0$formal$../rtl/test_UART.v:98$15_EN[0:0]$57
    28/40: $0$formal$../rtl/test_UART.v:98$15_CHECK[0:0]$56
    29/40: $0$formal$../rtl/test_UART.v:104$16_EN[0:0]$59
    30/40: $0$formal$../rtl/test_UART.v:104$16_CHECK[0:0]$58
    31/40: $0$formal$../rtl/test_UART.v:105$17_EN[0:0]$61
    32/40: $0$formal$../rtl/test_UART.v:105$17_CHECK[0:0]$60
    33/40: $0$formal$../rtl/test_UART.v:106$18_EN[0:0]$63
    34/40: $0$formal$../rtl/test_UART.v:106$18_CHECK[0:0]$62
    35/40: $0$formal$../rtl/test_UART.v:107$19_EN[0:0]$65
    36/40: $0$formal$../rtl/test_UART.v:107$19_CHECK[0:0]$64
    37/40: $0$formal$../rtl/test_UART.v:108$20_EN[0:0]$67
    38/40: $0$formal$../rtl/test_UART.v:108$20_CHECK[0:0]$66
    39/40: $0\cnt[6:0]
    40/40: $0\has_been_enabled[0:0]

17.2.6. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `\synchronizer.$formal$../rtl/Rx/synchronizer.v:18$238_CHECK' from process `\synchronizer.$proc$../rtl/Rx/synchronizer.v:17$248'.
No latch inferred for signal `\synchronizer.$formal$../rtl/Rx/synchronizer.v:18$238_EN' from process `\synchronizer.$proc$../rtl/Rx/synchronizer.v:17$248'.
No latch inferred for signal `\synchronizer.$formal$../rtl/Rx/synchronizer.v:19$240_CHECK' from process `\synchronizer.$proc$../rtl/Rx/synchronizer.v:17$248'.
No latch inferred for signal `\synchronizer.$formal$../rtl/Rx/synchronizer.v:19$240_EN' from process `\synchronizer.$proc$../rtl/Rx/synchronizer.v:17$248'.
No latch inferred for signal `\synchronizer.$formal$../rtl/Rx/synchronizer.v:20$242_CHECK' from process `\synchronizer.$proc$../rtl/Rx/synchronizer.v:17$248'.
No latch inferred for signal `\synchronizer.$formal$../rtl/Rx/synchronizer.v:20$242_EN' from process `\synchronizer.$proc$../rtl/Rx/synchronizer.v:17$248'.

17.2.7. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\SIPO_shift_register.\received_data' using process `\SIPO_shift_register.$proc$../rtl/Rx/SIPO_shift_register.v:8$273'.
  created $dff cell `$procdff$954' with positive edge clock.
Creating register for signal `\sampling_strobe_generator.$past$../rtl/Rx/sampling_strobe_generator.v:34$258$0' using process `\sampling_strobe_generator.$proc$../rtl/Rx/sampling_strobe_generator.v:32$264'.
  created $dff cell `$procdff$955' with positive edge clock.
Creating register for signal `\sampling_strobe_generator.$formal$../rtl/Rx/sampling_strobe_generator.v:34$259_CHECK' using process `\sampling_strobe_generator.$proc$../rtl/Rx/sampling_strobe_generator.v:32$264'.
  created $dff cell `$procdff$956' with positive edge clock.
Creating register for signal `\sampling_strobe_generator.$formal$../rtl/Rx/sampling_strobe_generator.v:34$259_EN' using process `\sampling_strobe_generator.$proc$../rtl/Rx/sampling_strobe_generator.v:32$264'.
  created $dff cell `$procdff$957' with positive edge clock.
Creating register for signal `\sampling_strobe_generator.\sampling_strobe' using process `\sampling_strobe_generator.$proc$../rtl/Rx/sampling_strobe_generator.v:22$262'.
  created $dff cell `$procdff$958' with positive edge clock.
Creating register for signal `\sampling_strobe_generator.\counter' using process `\sampling_strobe_generator.$proc$../rtl/Rx/sampling_strobe_generator.v:14$260'.
  created $dff cell `$procdff$959' with positive edge clock.
Creating register for signal `\synchronizer.\serial_in_synced' using process `\synchronizer.$proc$../rtl/Rx/synchronizer.v:8$244'.
  created $dff cell `$procdff$960' with positive edge clock.
Creating register for signal `\synchronizer.\serial_in_reg' using process `\synchronizer.$proc$../rtl/Rx/synchronizer.v:8$244'.
  created $dff cell `$procdff$961' with positive edge clock.
Creating register for signal `\synchronizer.\serial_in_reg2' using process `\synchronizer.$proc$../rtl/Rx/synchronizer.v:8$244'.
  created $dff cell `$procdff$962' with positive edge clock.
Creating register for signal `\detect_start_bit.$formal$../rtl/Rx/detect_start_bit.v:57$295_CHECK' using process `\detect_start_bit.$proc$../rtl/Rx/detect_start_bit.v:54$303'.
  created $dff cell `$procdff$963' with positive edge clock.
Creating register for signal `\detect_start_bit.$formal$../rtl/Rx/detect_start_bit.v:57$295_EN' using process `\detect_start_bit.$proc$../rtl/Rx/detect_start_bit.v:54$303'.
  created $dff cell `$procdff$964' with positive edge clock.
Creating register for signal `\detect_start_bit.\previously_idle' using process `\detect_start_bit.$proc$../rtl/Rx/detect_start_bit.v:43$302'.
  created $dff cell `$procdff$965' with positive edge clock.
Creating register for signal `\detect_start_bit.\start_detected' using process `\detect_start_bit.$proc$../rtl/Rx/detect_start_bit.v:30$298'.
  created $dff cell `$procdff$966' with positive edge clock.
Creating register for signal `\detect_start_bit.\clocks_since_start_bit' using process `\detect_start_bit.$proc$../rtl/Rx/detect_start_bit.v:30$298'.
  created $dff cell `$procdff$967' with positive edge clock.
Creating register for signal `\check_parity.\rx_error' using process `\check_parity.$proc$../rtl/Rx/check_parity.v:12$291'.
  created $dff cell `$procdff$968' with positive edge clock.
Creating register for signal `\check_parity.\parity_bit' using process `\check_parity.$proc$../rtl/Rx/check_parity.v:12$291'.
  created $dff cell `$procdff$969' with positive edge clock.
Creating register for signal `\check_parity.\parity_value' using process `\check_parity.$proc$../rtl/Rx/check_parity.v:12$291'.
  created $dff cell `$procdff$970' with positive edge clock.
Creating register for signal `\baud_generator.\cnt' using process `\baud_generator.$proc$../rtl/Tx/baud_generator.v:21$219'.
  created $dff cell `$procdff$971' with positive edge clock.
Creating register for signal `\baud_generator.\ck_stb' using process `\baud_generator.$proc$../rtl/Tx/baud_generator.v:21$219'.
  created $dff cell `$procdff$972' with positive edge clock.
Creating register for signal `\rx_state.$formal$../rtl/Rx/rx_state.v:75$274_EN' using process `\rx_state.$proc$../rtl/Rx/rx_state.v:73$284'.
  created $dff cell `$procdff$973' with positive edge clock.
Creating register for signal `\rx_state.$formal$../rtl/Rx/rx_state.v:75$274_CHECK' using process `\rx_state.$proc$../rtl/Rx/rx_state.v:73$284'.
  created $dff cell `$procdff$974' with positive edge clock.
Creating register for signal `\rx_state.\state' using process `\rx_state.$proc$../rtl/Rx/rx_state.v:40$281'.
  created $dff cell `$procdff$975' with positive edge clock.
Creating register for signal `\rx_state.\data_is_valid' using process `\rx_state.$proc$../rtl/Rx/rx_state.v:33$275'.
  created $dff cell `$procdff$976' with positive edge clock.
Creating register for signal `\rx_state.\is_parity_stage' using process `\rx_state.$proc$../rtl/Rx/rx_state.v:33$275'.
  created $dff cell `$procdff$977' with positive edge clock.
Creating register for signal `\rx_state.\data_is_available' using process `\rx_state.$proc$../rtl/Rx/rx_state.v:33$275'.
  created $dff cell `$procdff$978' with positive edge clock.
Creating register for signal `\TxUART.\o_busy' using process `\TxUART.$proc$../rtl/Tx/TxUART.v:55$208'.
  created $dff cell `$procdff$979' with positive edge clock.
Creating register for signal `\TxUART.\serial_out' using process `\TxUART.$proc$../rtl/Tx/TxUART.v:40$207'.
  created $dff cell `$procdff$980' with positive edge clock.
Creating register for signal `\TxUART.\shift_reg' using process `\TxUART.$proc$../rtl/Tx/TxUART.v:21$204'.
  created $dff cell `$procdff$981' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:133$26_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:131$111'.
  created $dff cell `$procdff$982' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:133$26_EN' using process `\test_UART.$proc$../rtl/test_UART.v:131$111'.
  created $dff cell `$procdff$983' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:136$27_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:131$111'.
  created $dff cell `$procdff$984' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:136$27_EN' using process `\test_UART.$proc$../rtl/test_UART.v:131$111'.
  created $dff cell `$procdff$985' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:137$28_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:131$111'.
  created $dff cell `$procdff$986' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:137$28_EN' using process `\test_UART.$proc$../rtl/test_UART.v:131$111'.
  created $dff cell `$procdff$987' with positive edge clock.
Creating register for signal `\test_UART.$past$../rtl/test_UART.v:120$1$0' using process `\test_UART.$proc$../rtl/test_UART.v:113$93'.
  created $dff cell `$procdff$988' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:116$21_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:113$93'.
  created $dff cell `$procdff$989' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:116$21_EN' using process `\test_UART.$proc$../rtl/test_UART.v:113$93'.
  created $dff cell `$procdff$990' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:120$22_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:113$93'.
  created $dff cell `$procdff$991' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:120$22_EN' using process `\test_UART.$proc$../rtl/test_UART.v:113$93'.
  created $dff cell `$procdff$992' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:121$23_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:113$93'.
  created $dff cell `$procdff$993' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:121$23_EN' using process `\test_UART.$proc$../rtl/test_UART.v:113$93'.
  created $dff cell `$procdff$994' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:125$24_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:113$93'.
  created $dff cell `$procdff$995' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:125$24_EN' using process `\test_UART.$proc$../rtl/test_UART.v:113$93'.
  created $dff cell `$procdff$996' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:126$25_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:113$93'.
  created $dff cell `$procdff$997' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:126$25_EN' using process `\test_UART.$proc$../rtl/test_UART.v:113$93'.
  created $dff cell `$procdff$998' with positive edge clock.
Creating register for signal `\test_UART.\has_been_enabled' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$999' with positive edge clock.
Creating register for signal `\test_UART.\cnt' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1000' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:67$2_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1001' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:67$2_EN' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1002' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:69$3_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1003' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:69$3_EN' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1004' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:70$4_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1005' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:70$4_EN' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1006' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:77$5_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1007' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:77$5_EN' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1008' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:78$6_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1009' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:78$6_EN' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1010' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:79$7_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1011' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:79$7_EN' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1012' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:83$8_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1013' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:83$8_EN' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1014' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:84$9_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1015' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:84$9_EN' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1016' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:85$10_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1017' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:85$10_EN' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1018' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:89$11_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1019' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:89$11_EN' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1020' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:90$12_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1021' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:90$12_EN' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1022' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:91$13_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1023' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:91$13_EN' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1024' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:97$14_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1025' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:97$14_EN' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1026' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:98$15_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1027' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:98$15_EN' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1028' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:104$16_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1029' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:104$16_EN' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1030' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:105$17_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1031' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:105$17_EN' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1032' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:106$18_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1033' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:106$18_EN' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1034' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:107$19_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1035' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:107$19_EN' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1036' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:108$20_CHECK' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1037' with positive edge clock.
Creating register for signal `\test_UART.$formal$../rtl/test_UART.v:108$20_EN' using process `\test_UART.$proc$../rtl/test_UART.v:57$29'.
  created $dff cell `$procdff$1038' with positive edge clock.

17.2.8. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 1 empty switch in `\SIPO_shift_register.$proc$../rtl/Rx/SIPO_shift_register.v:8$273'.
Removing empty process `SIPO_shift_register.$proc$../rtl/Rx/SIPO_shift_register.v:8$273'.
Removing empty process `sampling_strobe_generator.$proc$../rtl/Rx/sampling_strobe_generator.v:34$271'.
Removing empty process `sampling_strobe_generator.$proc$../rtl/Rx/sampling_strobe_generator.v:32$264'.
Found and cleaned up 1 empty switch in `\sampling_strobe_generator.$proc$../rtl/Rx/sampling_strobe_generator.v:22$262'.
Removing empty process `sampling_strobe_generator.$proc$../rtl/Rx/sampling_strobe_generator.v:22$262'.
Found and cleaned up 1 empty switch in `\sampling_strobe_generator.$proc$../rtl/Rx/sampling_strobe_generator.v:14$260'.
Removing empty process `sampling_strobe_generator.$proc$../rtl/Rx/sampling_strobe_generator.v:14$260'.
Removing empty process `synchronizer.$proc$../rtl/Rx/synchronizer.v:17$248'.
Removing empty process `synchronizer.$proc$../rtl/Rx/synchronizer.v:8$244'.
Removing empty process `detect_start_bit.$proc$../rtl/Rx/detect_start_bit.v:57$312'.
Removing empty process `detect_start_bit.$proc$../rtl/Rx/detect_start_bit.v:23$311'.
Found and cleaned up 1 empty switch in `\detect_start_bit.$proc$../rtl/Rx/detect_start_bit.v:54$303'.
Removing empty process `detect_start_bit.$proc$../rtl/Rx/detect_start_bit.v:54$303'.
Found and cleaned up 1 empty switch in `\detect_start_bit.$proc$../rtl/Rx/detect_start_bit.v:43$302'.
Removing empty process `detect_start_bit.$proc$../rtl/Rx/detect_start_bit.v:43$302'.
Found and cleaned up 1 empty switch in `\detect_start_bit.$proc$../rtl/Rx/detect_start_bit.v:30$298'.
Removing empty process `detect_start_bit.$proc$../rtl/Rx/detect_start_bit.v:30$298'.
Removing empty process `check_parity.$proc$../rtl/Rx/check_parity.v:7$294'.
Found and cleaned up 1 empty switch in `\check_parity.$proc$../rtl/Rx/check_parity.v:12$291'.
Removing empty process `check_parity.$proc$../rtl/Rx/check_parity.v:12$291'.
Removing empty process `baud_generator.$proc$../rtl/Tx/baud_generator.v:19$223'.
Removing empty process `baud_generator.$proc$../rtl/Tx/baud_generator.v:18$222'.
Removing empty process `baud_generator.$proc$../rtl/Tx/baud_generator.v:21$219'.
Removing empty process `rx_state.$proc$../rtl/Rx/rx_state.v:75$289'.
Removing empty process `rx_state.$proc$../rtl/Rx/rx_state.v:73$284'.
Found and cleaned up 3 empty switches in `\rx_state.$proc$../rtl/Rx/rx_state.v:40$281'.
Removing empty process `rx_state.$proc$../rtl/Rx/rx_state.v:40$281'.
Removing empty process `rx_state.$proc$../rtl/Rx/rx_state.v:33$275'.
Removing empty process `TxUART.$proc$../rtl/Tx/TxUART.v:15$215'.
Found and cleaned up 1 empty switch in `\TxUART.$proc$../rtl/Tx/TxUART.v:55$208'.
Removing empty process `TxUART.$proc$../rtl/Tx/TxUART.v:55$208'.
Found and cleaned up 3 empty switches in `\TxUART.$proc$../rtl/Tx/TxUART.v:40$207'.
Removing empty process `TxUART.$proc$../rtl/Tx/TxUART.v:40$207'.
Found and cleaned up 4 empty switches in `\TxUART.$proc$../rtl/Tx/TxUART.v:21$204'.
Removing empty process `TxUART.$proc$../rtl/Tx/TxUART.v:21$204'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:137$202'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:136$200'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:133$198'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:126$196'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:125$194'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:121$192'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:120$190'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:116$188'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:108$186'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:107$184'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:106$182'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:105$180'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:104$178'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:98$176'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:97$174'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:91$172'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:90$170'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:89$168'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:85$166'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:84$164'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:83$162'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:79$160'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:78$158'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:77$156'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:70$154'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:69$152'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:67$150'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:55$149'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:54$148'.
Found and cleaned up 1 empty switch in `\test_UART.$proc$../rtl/test_UART.v:131$111'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:131$111'.
Found and cleaned up 2 empty switches in `\test_UART.$proc$../rtl/test_UART.v:113$93'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:113$93'.
Found and cleaned up 6 empty switches in `\test_UART.$proc$../rtl/test_UART.v:57$29'.
Removing empty process `test_UART.$proc$../rtl/test_UART.v:57$29'.
Cleaned up 27 empty switches.

17.3. Executing OPT_EXPR pass (perform const folding).
Replacing $eq cell `$eq$../rtl/Rx/sampling_strobe_generator.v:34$269' in module `sampling_strobe_generator' with $logic_not.
Replacing $eq cell `$eq$../rtl/Rx/synchronizer.v:18$255' (1) in module `\synchronizer' with constant driver `$eq$../rtl/Rx/synchronizer.v:18$255_Y = \serial_in_reg'.
Replacing $eq cell `$eq$../rtl/Rx/synchronizer.v:19$256' (1) in module `\synchronizer' with constant driver `$eq$../rtl/Rx/synchronizer.v:19$256_Y = \serial_in_reg2'.
Replacing $eq cell `$eq$../rtl/Rx/synchronizer.v:20$257' (1) in module `\synchronizer' with constant driver `$eq$../rtl/Rx/synchronizer.v:20$257_Y = \serial_in_synced'.
Replacing $eq cell `$eq$../rtl/Rx/detect_start_bit.v:56$306' in module `detect_start_bit' with $logic_not.
Replacing $eq cell `$eq$../rtl/Rx/detect_start_bit.v:57$309' in module `detect_start_bit' with inverter.
Replacing $eq cell `$procmux$354_CMP0' in module `rx_state' with $logic_not.
Replacing $ne cell `$ne$../rtl/Tx/TxUART.v:62$209' in module `TxUART' with $logic_not.
Replacing $eq cell `$eq$../rtl/test_UART.v:67$70' in module `test_UART' with $logic_not.
Replacing $eq cell `$eq$../rtl/test_UART.v:69$71' in module `test_UART' with inverter.
Replacing $eq cell `$eq$../rtl/test_UART.v:70$72' (1) in module `\test_UART' with constant driver `$eq$../rtl/test_UART.v:70$72_Y = \serial_out'.
Replacing $eq cell `$eq$../rtl/test_UART.v:77$75' in module `test_UART' with inverter.
Replacing $eq cell `$eq$../rtl/test_UART.v:78$76' in module `test_UART' with inverter.
Replacing $eq cell `$eq$../rtl/test_UART.v:79$77' (1) in module `\test_UART' with constant driver `$eq$../rtl/test_UART.v:79$77_Y = \o_busy'.
Replacing $eq cell `$eq$../rtl/test_UART.v:83$79' in module `test_UART' with inverter.
Replacing $eq cell `$eq$../rtl/test_UART.v:84$80' (1) in module `\test_UART' with constant driver `$eq$../rtl/test_UART.v:84$80_Y = \serial_out'.
Replacing $eq cell `$eq$../rtl/test_UART.v:85$81' (1) in module `\test_UART' with constant driver `$eq$../rtl/test_UART.v:85$81_Y = \o_busy'.
Replacing $eq cell `$eq$../rtl/test_UART.v:90$84' (1) in module `\test_UART' with constant driver `$eq$../rtl/test_UART.v:90$84_Y = \data_is_valid'.
Replacing $eq cell `$eq$../rtl/test_UART.v:91$85' (1) in module `\test_UART' with constant driver `$eq$../rtl/test_UART.v:91$85_Y = \serial_out'.
Replacing $eq cell `$eq$../rtl/test_UART.v:97$86' in module `test_UART' with inverter.
Replacing $eq cell `$eq$../rtl/test_UART.v:98$87' (1) in module `\test_UART' with constant driver `$eq$../rtl/test_UART.v:98$87_Y = \o_busy'.
Replacing $eq cell `$eq$../rtl/test_UART.v:104$88' in module `test_UART' with $logic_not.
Replacing $eq cell `$eq$../rtl/test_UART.v:105$89' in module `test_UART' with $logic_not.
Replacing $eq cell `$eq$../rtl/test_UART.v:106$90' in module `test_UART' with inverter.
Replacing $eq cell `$eq$../rtl/test_UART.v:107$91' (1) in module `\test_UART' with constant driver `$eq$../rtl/test_UART.v:107$91_Y = \serial_out'.
Replacing $eq cell `$eq$../rtl/test_UART.v:108$92' in module `test_UART' with inverter.
Replacing $eq cell `$eq$../rtl/test_UART.v:116$106' in module `test_UART' with inverter.
Replacing $eq cell `$eq$../rtl/test_UART.v:121$108' (1) in module `\test_UART' with constant driver `$eq$../rtl/test_UART.v:121$108_Y = \o_busy'.
Replacing $eq cell `$eq$../rtl/test_UART.v:125$109' in module `test_UART' with inverter.
Replacing $eq cell `$eq$../rtl/test_UART.v:126$110' (1) in module `\test_UART' with constant driver `$eq$../rtl/test_UART.v:126$110_Y = \serial_out'.

17.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \SIPO_shift_register..
  removed 2 unused temporary wires.
Finding unused cells or wires in module \sampling_strobe_generator..
  removed 8 unused temporary wires.
Finding unused cells or wires in module \RxUART..
Finding unused cells or wires in module \synchronizer..
  removed 18 unused temporary wires.
Finding unused cells or wires in module \Rx_top..
Finding unused cells or wires in module \detect_start_bit..
  removed 15 unused temporary wires.
Finding unused cells or wires in module \check_parity..
  removed 7 unused temporary wires.
Finding unused cells or wires in module \Tx_top..
  removed 1 unused temporary wires.
Finding unused cells or wires in module \baud_generator..
  removed 3 unused temporary wires.
Finding unused cells or wires in module \rx_state..
  removed 9 unused temporary wires.
Finding unused cells or wires in module \TxUART..
  removed 13 unused temporary wires.
Finding unused cells or wires in module \UART..
Finding unused cells or wires in module \test_UART..
  removed 286 unused temporary wires.
Removed 0 unused cells and 362 unused wires.

17.5. Executing CHECK pass (checking for obvious problems).
checking module RxUART..
checking module Rx_top..
checking module SIPO_shift_register..
checking module TxUART..
checking module Tx_top..
checking module UART..
checking module baud_generator..
checking module check_parity..
checking module detect_start_bit..
checking module rx_state..
checking module sampling_strobe_generator..
checking module synchronizer..
checking module test_UART..
found and reported 0 problems.

17.6. Executing OPT pass (performing simple optimizations).

17.6.1. Executing OPT_EXPR pass (perform const folding).

17.6.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\RxUART'.
Finding identical cells in module `\Rx_top'.
Finding identical cells in module `\SIPO_shift_register'.
Finding identical cells in module `\TxUART'.
Finding identical cells in module `\Tx_top'.
Finding identical cells in module `\UART'.
Finding identical cells in module `\baud_generator'.
Finding identical cells in module `\check_parity'.
Finding identical cells in module `\detect_start_bit'.
Finding identical cells in module `\rx_state'.
  Cell `$procmux$351_CMP0' is identical to cell `$eq$../rtl/Rx/rx_state.v:36$277'.
    Redirecting output \Y: $procmux$351_CMP = $0\is_parity_stage[0:0]
    Removing $eq cell `$procmux$351_CMP0' from module `\rx_state'.
Finding identical cells in module `\sampling_strobe_generator'.
Finding identical cells in module `\synchronizer'.
  Cell `$initstate$241' is identical to cell `$initstate$239'.
    Redirecting output \Y: $0$formal$../rtl/Rx/synchronizer.v:19$240_EN[0:0]$252 = $0$formal$../rtl/Rx/synchronizer.v:18$238_EN[0:0]$250
    Removing $initstate cell `$initstate$241' from module `\synchronizer'.
  Cell `$initstate$243' is identical to cell `$initstate$239'.
    Redirecting output \Y: $0$formal$../rtl/Rx/synchronizer.v:20$242_EN[0:0]$254 = $0$formal$../rtl/Rx/synchronizer.v:18$238_EN[0:0]$250
    Removing $initstate cell `$initstate$243' from module `\synchronizer'.
Finding identical cells in module `\test_UART'.
  Cell `$eq$../rtl/test_UART.v:125$109' is identical to cell `$eq$../rtl/test_UART.v:108$92'.
    Redirecting output \Y: $eq$../rtl/test_UART.v:125$109_Y = $eq$../rtl/test_UART.v:108$92_Y
    Removing $not cell `$eq$../rtl/test_UART.v:125$109' from module `\test_UART'.
  Cell `$eq$../rtl/test_UART.v:67$70' is identical to cell `$eq$../rtl/test_UART.v:104$88'.
    Redirecting output \Y: $eq$../rtl/test_UART.v:67$70_Y = $eq$../rtl/test_UART.v:104$88_Y
    Removing $logic_not cell `$eq$../rtl/test_UART.v:67$70' from module `\test_UART'.
  Cell `$eq$../rtl/test_UART.v:69$71' is identical to cell `$eq$../rtl/test_UART.v:106$90'.
    Redirecting output \Y: $eq$../rtl/test_UART.v:69$71_Y = $eq$../rtl/test_UART.v:106$90_Y
    Removing $not cell `$eq$../rtl/test_UART.v:69$71' from module `\test_UART'.
  Cell `$eq$../rtl/test_UART.v:77$75' is identical to cell `$eq$../rtl/test_UART.v:106$90'.
    Redirecting output \Y: $eq$../rtl/test_UART.v:77$75_Y = $eq$../rtl/test_UART.v:106$90_Y
    Removing $not cell `$eq$../rtl/test_UART.v:77$75' from module `\test_UART'.
  Cell `$eq$../rtl/test_UART.v:83$79' is identical to cell `$eq$../rtl/test_UART.v:106$90'.
    Redirecting output \Y: $eq$../rtl/test_UART.v:83$79_Y = $eq$../rtl/test_UART.v:106$90_Y
    Removing $not cell `$eq$../rtl/test_UART.v:83$79' from module `\test_UART'.
  Cell `$eq$../rtl/test_UART.v:97$86' is identical to cell `$eq$../rtl/test_UART.v:106$90'.
    Redirecting output \Y: $eq$../rtl/test_UART.v:97$86_Y = $eq$../rtl/test_UART.v:106$90_Y
    Removing $not cell `$eq$../rtl/test_UART.v:97$86' from module `\test_UART'.
Removed a total of 9 cells.

17.6.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \RxUART..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \Rx_top..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \SIPO_shift_register..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
    Root of a mux tree: $procmux$315 (pure)
  Analyzing evaluation results.
Running muxtree optimizer on module \TxUART..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
    Root of a mux tree: $procmux$361 (pure)
    Root of a mux tree: $procmux$370 (pure)
    Root of a mux tree: $procmux$373
    Root of a mux tree: $procmux$382 (pure)
  Analyzing evaluation results.
Running muxtree optimizer on module \Tx_top..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \UART..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \baud_generator..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \check_parity..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
    Root of a mux tree: $procmux$339 (pure)
    Root of a mux tree: $procmux$342 (pure)
    Root of a mux tree: $procmux$345 (pure)
  Analyzing evaluation results.
Running muxtree optimizer on module \detect_start_bit..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
    Root of a mux tree: $procmux$324 (pure)
    Root of a mux tree: $procmux$327 (pure)
    Root of a mux tree: $procmux$330 (pure)
    Root of a mux tree: $procmux$333 (pure)
    Root of a mux tree: $procmux$336 (pure)
  Analyzing evaluation results.
Running muxtree optimizer on module \rx_state..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
    Root of a mux tree: $procmux$358 (pure)
  Analyzing evaluation results.
Running muxtree optimizer on module \sampling_strobe_generator..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
    Root of a mux tree: $procmux$318 (pure)
    Root of a mux tree: $procmux$321 (pure)
  Analyzing evaluation results.
Running muxtree optimizer on module \synchronizer..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \test_UART..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
    Root of a mux tree: $procmux$385 (pure)
    Root of a mux tree: $procmux$388 (pure)
    Root of a mux tree: $procmux$391 (pure)
    Root of a mux tree: $procmux$394 (pure)
    Root of a mux tree: $procmux$397 (pure)
    Root of a mux tree: $procmux$400 (pure)
    Root of a mux tree: $procmux$406 (pure)
    Root of a mux tree: $procmux$412 (pure)
    Root of a mux tree: $procmux$418 (pure)
    Root of a mux tree: $procmux$424 (pure)
    Root of a mux tree: $procmux$430 (pure)
    Root of a mux tree: $procmux$436 (pure)
    Root of a mux tree: $procmux$442 (pure)
    Root of a mux tree: $procmux$448 (pure)
    Root of a mux tree: $procmux$454 (pure)
    Root of a mux tree: $procmux$460 (pure)
    Root of a mux tree: $procmux$466 (pure)
    Root of a mux tree: $procmux$472 (pure)
    Root of a mux tree: $procmux$478 (pure)
    Root of a mux tree: $procmux$484 (pure)
    Root of a mux tree: $procmux$496 (pure)
    Root of a mux tree: $procmux$508 (pure)
    Root of a mux tree: $procmux$520 (pure)
    Root of a mux tree: $procmux$532 (pure)
    Root of a mux tree: $procmux$544 (pure)
    Root of a mux tree: $procmux$556 (pure)
    Root of a mux tree: $procmux$571 (pure)
    Root of a mux tree: $procmux$586 (pure)
    Root of a mux tree: $procmux$601 (pure)
    Root of a mux tree: $procmux$616 (pure)
    Root of a mux tree: $procmux$631 (pure)
    Root of a mux tree: $procmux$646 (pure)
    Root of a mux tree: $procmux$664 (pure)
    Root of a mux tree: $procmux$682 (pure)
    Root of a mux tree: $procmux$700 (pure)
    Root of a mux tree: $procmux$718 (pure)
    Root of a mux tree: $procmux$736 (pure)
    Root of a mux tree: $procmux$754 (pure)
    Root of a mux tree: $procmux$772 (pure)
    Root of a mux tree: $procmux$790 (pure)
    Root of a mux tree: $procmux$808 (pure)
    Root of a mux tree: $procmux$826 (pure)
    Root of a mux tree: $procmux$835 (pure)
    Root of a mux tree: $procmux$844 (pure)
    Root of a mux tree: $procmux$853 (pure)
    Root of a mux tree: $procmux$862 (pure)
    Root of a mux tree: $procmux$871 (pure)
    Root of a mux tree: $procmux$880 (pure)
    Root of a mux tree: $procmux$889 (pure)
    Root of a mux tree: $procmux$898 (pure)
    Root of a mux tree: $procmux$907 (pure)
    Root of a mux tree: $procmux$916 (pure)
    Root of a mux tree: $procmux$934 (pure)
    Root of a mux tree: $procmux$952 (pure)
      Replacing known input bits on port A of cell $procmux$946: \has_been_enabled -> 1'0
      Replacing known input bits on port B of cell $procmux$944: \has_been_enabled -> 1'1
      Replacing known input bits on port B of cell $procmux$941: \has_been_enabled -> 1'1
      Replacing known input bits on port A of cell $procmux$938: \has_been_enabled -> 1'1
  Analyzing evaluation results.
Removed 0 multiplexer ports.

17.6.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \RxUART.
  Optimizing cells in module \Rx_top.
  Optimizing cells in module \SIPO_shift_register.
  Optimizing cells in module \TxUART.
    New input vector for $reduce_and cell $reduce_and$../rtl/Tx/TxUART.v:62$210: { \shift_reg [0] \shift_reg [1] \shift_reg [2] \shift_reg [3] \shift_reg [4] \shift_reg [5] \shift_reg [6] \shift_reg [7] \shift_reg [8] \shift_reg [9] \shift_reg [10] }
  Optimizing cells in module \TxUART.
  Optimizing cells in module \Tx_top.
  Optimizing cells in module \UART.
  Optimizing cells in module \baud_generator.
  Optimizing cells in module \check_parity.
  Optimizing cells in module \detect_start_bit.
  Optimizing cells in module \rx_state.
    New input vector for $reduce_or cell $procmux$352_ANY: { $procmux$352_CMP [0] $procmux$352_CMP [1] $procmux$352_CMP [2] $procmux$352_CMP [3] $procmux$352_CMP [4] $procmux$352_CMP [5] $procmux$352_CMP [6] $procmux$352_CMP [7] }
  Optimizing cells in module \rx_state.
  Optimizing cells in module \sampling_strobe_generator.
  Optimizing cells in module \synchronizer.
  Optimizing cells in module \test_UART.
Performed a total of 2 changes.

17.6.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\RxUART'.
Finding identical cells in module `\Rx_top'.
Finding identical cells in module `\SIPO_shift_register'.
Finding identical cells in module `\TxUART'.
Finding identical cells in module `\Tx_top'.
Finding identical cells in module `\UART'.
Finding identical cells in module `\baud_generator'.
Finding identical cells in module `\check_parity'.
Finding identical cells in module `\detect_start_bit'.
Finding identical cells in module `\rx_state'.
Finding identical cells in module `\sampling_strobe_generator'.
Finding identical cells in module `\synchronizer'.
Finding identical cells in module `\test_UART'.
  Cell `$procmux$391' is identical to cell `$procmux$385'.
    Redirecting output \Y: $0$formal$../rtl/test_UART.v:137$28_EN[0:0]$117 = $0$formal$../rtl/test_UART.v:136$27_EN[0:0]$115
    Removing $mux cell `$procmux$391' from module `\test_UART'.
  Cell `$procmux$415' is identical to cell `$procmux$403'.
    Redirecting output \Y: $procmux$415_Y = $procmux$403_Y
    Removing $mux cell `$procmux$415' from module `\test_UART'.
  Cell `$procmux$418' is identical to cell `$procmux$406'.
    Redirecting output \Y: $0$formal$../rtl/test_UART.v:121$23_EN[0:0]$100 = $0$formal$../rtl/test_UART.v:120$22_EN[0:0]$98
    Removing $mux cell `$procmux$418' from module `\test_UART'.
  Cell `$procmux$439' is identical to cell `$procmux$427'.
    Redirecting output \Y: $procmux$439_Y = $procmux$427_Y
    Removing $mux cell `$procmux$439' from module `\test_UART'.
  Cell `$procmux$442' is identical to cell `$procmux$430'.
    Redirecting output \Y: $0$formal$../rtl/test_UART.v:126$25_EN[0:0]$104 = $0$formal$../rtl/test_UART.v:125$24_EN[0:0]$102
    Removing $mux cell `$procmux$442' from module `\test_UART'.
  Cell `$procmux$463' is identical to cell `$procmux$451'.
    Redirecting output \Y: $procmux$463_Y = $procmux$451_Y
    Removing $mux cell `$procmux$463' from module `\test_UART'.
  Cell `$procmux$466' is identical to cell `$procmux$454'.
    Redirecting output \Y: $0$formal$../rtl/test_UART.v:69$3_EN[0:0]$33 = $0$formal$../rtl/test_UART.v:67$2_EN[0:0]$31
    Removing $mux cell `$procmux$466' from module `\test_UART'.
  Cell `$procmux$475' is identical to cell `$procmux$451'.
    Redirecting output \Y: $procmux$475_Y = $procmux$451_Y
    Removing $mux cell `$procmux$475' from module `\test_UART'.
  Cell `$procmux$478' is identical to cell `$procmux$454'.
    Redirecting output \Y: $0$formal$../rtl/test_UART.v:70$4_EN[0:0]$35 = $0$formal$../rtl/test_UART.v:67$2_EN[0:0]$31
    Removing $mux cell `$procmux$478' from module `\test_UART'.
  Cell `$procmux$512' is identical to cell `$procmux$488'.
    Redirecting output \Y: $procmux$512_Y = $procmux$488_Y
    Removing $mux cell `$procmux$512' from module `\test_UART'.
  Cell `$procmux$514' is identical to cell `$procmux$490'.
    Redirecting output \Y: $procmux$514_Y = $procmux$490_Y
    Removing $mux cell `$procmux$514' from module `\test_UART'.
  Cell `$procmux$517' is identical to cell `$procmux$493'.
    Redirecting output \Y: $procmux$517_Y = $procmux$493_Y
    Removing $mux cell `$procmux$517' from module `\test_UART'.
  Cell `$procmux$520' is identical to cell `$procmux$496'.
    Redirecting output \Y: $0$formal$../rtl/test_UART.v:78$6_EN[0:0]$39 = $0$formal$../rtl/test_UART.v:77$5_EN[0:0]$37
    Removing $mux cell `$procmux$520' from module `\test_UART'.
  Cell `$procmux$536' is identical to cell `$procmux$488'.
    Redirecting output \Y: $procmux$536_Y = $procmux$488_Y
    Removing $mux cell `$procmux$536' from module `\test_UART'.
  Cell `$procmux$538' is identical to cell `$procmux$490'.
    Redirecting output \Y: $procmux$538_Y = $procmux$490_Y
    Removing $mux cell `$procmux$538' from module `\test_UART'.
  Cell `$procmux$541' is identical to cell `$procmux$493'.
    Redirecting output \Y: $procmux$541_Y = $procmux$493_Y
    Removing $mux cell `$procmux$541' from module `\test_UART'.
  Cell `$procmux$544' is identical to cell `$procmux$496'.
    Redirecting output \Y: $0$formal$../rtl/test_UART.v:79$7_EN[0:0]$41 = $0$formal$../rtl/test_UART.v:77$5_EN[0:0]$37
    Removing $mux cell `$procmux$544' from module `\test_UART'.
  Cell `$procmux$590' is identical to cell `$procmux$560'.
    Redirecting output \Y: $procmux$590_Y = $procmux$560_Y
    Removing $mux cell `$procmux$590' from module `\test_UART'.
  Cell `$procmux$593' is identical to cell `$procmux$563'.
    Redirecting output \Y: $procmux$593_Y = $procmux$563_Y
    Removing $mux cell `$procmux$593' from module `\test_UART'.
  Cell `$procmux$595' is identical to cell `$procmux$565'.
    Redirecting output \Y: $procmux$595_Y = $procmux$565_Y
    Removing $mux cell `$procmux$595' from module `\test_UART'.
  Cell `$procmux$598' is identical to cell `$procmux$568'.
    Redirecting output \Y: $procmux$598_Y = $procmux$568_Y
    Removing $mux cell `$procmux$598' from module `\test_UART'.
  Cell `$procmux$601' is identical to cell `$procmux$571'.
    Redirecting output \Y: $0$formal$../rtl/test_UART.v:84$9_EN[0:0]$45 = $0$formal$../rtl/test_UART.v:83$8_EN[0:0]$43
    Removing $mux cell `$procmux$601' from module `\test_UART'.
  Cell `$procmux$620' is identical to cell `$procmux$560'.
    Redirecting output \Y: $procmux$620_Y = $procmux$560_Y
    Removing $mux cell `$procmux$620' from module `\test_UART'.
  Cell `$procmux$623' is identical to cell `$procmux$563'.
    Redirecting output \Y: $procmux$623_Y = $procmux$563_Y
    Removing $mux cell `$procmux$623' from module `\test_UART'.
  Cell `$procmux$625' is identical to cell `$procmux$565'.
    Redirecting output \Y: $procmux$625_Y = $procmux$565_Y
    Removing $mux cell `$procmux$625' from module `\test_UART'.
  Cell `$procmux$628' is identical to cell `$procmux$568'.
    Redirecting output \Y: $procmux$628_Y = $procmux$568_Y
    Removing $mux cell `$procmux$628' from module `\test_UART'.
  Cell `$procmux$631' is identical to cell `$procmux$571'.
    Redirecting output \Y: $0$formal$../rtl/test_UART.v:85$10_EN[0:0]$47 = $0$formal$../rtl/test_UART.v:83$8_EN[0:0]$43
    Removing $mux cell `$procmux$631' from module `\test_UART'.
  Cell `$procmux$686' is identical to cell `$procmux$650'.
    Redirecting output \Y: $procmux$686_Y = $procmux$650_Y
    Removing $mux cell `$procmux$686' from module `\test_UART'.
  Cell `$procmux$689' is identical to cell `$procmux$653'.
    Redirecting output \Y: $procmux$689_Y = $procmux$653_Y
    Removing $mux cell `$procmux$689' from module `\test_UART'.
  Cell `$procmux$692' is identical to cell `$procmux$656'.
    Redirecting output \Y: $procmux$692_Y = $procmux$656_Y
    Removing $mux cell `$procmux$692' from module `\test_UART'.
  Cell `$procmux$694' is identical to cell `$procmux$658'.
    Redirecting output \Y: $procmux$694_Y = $procmux$658_Y
    Removing $mux cell `$procmux$694' from module `\test_UART'.
  Cell `$procmux$697' is identical to cell `$procmux$661'.
    Redirecting output \Y: $procmux$697_Y = $procmux$661_Y
    Removing $mux cell `$procmux$697' from module `\test_UART'.
  Cell `$procmux$700' is identical to cell `$procmux$664'.
    Redirecting output \Y: $0$formal$../rtl/test_UART.v:90$12_EN[0:0]$51 = $0$formal$../rtl/test_UART.v:89$11_EN[0:0]$49
    Removing $mux cell `$procmux$700' from module `\test_UART'.
  Cell `$procmux$722' is identical to cell `$procmux$650'.
    Redirecting output \Y: $procmux$722_Y = $procmux$650_Y
    Removing $mux cell `$procmux$722' from module `\test_UART'.
  Cell `$procmux$725' is identical to cell `$procmux$653'.
    Redirecting output \Y: $procmux$725_Y = $procmux$653_Y
    Removing $mux cell `$procmux$725' from module `\test_UART'.
  Cell `$procmux$728' is identical to cell `$procmux$656'.
    Redirecting output \Y: $procmux$728_Y = $procmux$656_Y
    Removing $mux cell `$procmux$728' from module `\test_UART'.
  Cell `$procmux$730' is identical to cell `$procmux$658'.
    Redirecting output \Y: $procmux$730_Y = $procmux$658_Y
    Removing $mux cell `$procmux$730' from module `\test_UART'.
  Cell `$procmux$733' is identical to cell `$procmux$661'.
    Redirecting output \Y: $procmux$733_Y = $procmux$661_Y
    Removing $mux cell `$procmux$733' from module `\test_UART'.
  Cell `$procmux$736' is identical to cell `$procmux$664'.
    Redirecting output \Y: $0$formal$../rtl/test_UART.v:91$13_EN[0:0]$53 = $0$formal$../rtl/test_UART.v:89$11_EN[0:0]$49
    Removing $mux cell `$procmux$736' from module `\test_UART'.
  Cell `$procmux$794' is identical to cell `$procmux$758'.
    Redirecting output \Y: $procmux$794_Y = $procmux$758_Y
    Removing $mux cell `$procmux$794' from module `\test_UART'.
  Cell `$procmux$797' is identical to cell `$procmux$761'.
    Redirecting output \Y: $procmux$797_Y = $procmux$761_Y
    Removing $mux cell `$procmux$797' from module `\test_UART'.
  Cell `$procmux$800' is identical to cell `$procmux$764'.
    Redirecting output \Y: $procmux$800_Y = $procmux$764_Y
    Removing $mux cell `$procmux$800' from module `\test_UART'.
  Cell `$procmux$802' is identical to cell `$procmux$766'.
    Redirecting output \Y: $procmux$802_Y = $procmux$766_Y
    Removing $mux cell `$procmux$802' from module `\test_UART'.
  Cell `$procmux$805' is identical to cell `$procmux$769'.
    Redirecting output \Y: $procmux$805_Y = $procmux$769_Y
    Removing $mux cell `$procmux$805' from module `\test_UART'.
  Cell `$procmux$808' is identical to cell `$procmux$772'.
    Redirecting output \Y: $0$formal$../rtl/test_UART.v:98$15_EN[0:0]$57 = $0$formal$../rtl/test_UART.v:97$14_EN[0:0]$55
    Removing $mux cell `$procmux$808' from module `\test_UART'.
  Cell `$procmux$829' is identical to cell `$procmux$427'.
    Redirecting output \Y: $procmux$829_Y = $procmux$427_Y
    Removing $mux cell `$procmux$829' from module `\test_UART'.
  Cell `$procmux$847' is identical to cell `$procmux$427'.
    Redirecting output \Y: $procmux$847_Y = $procmux$427_Y
    Removing $mux cell `$procmux$847' from module `\test_UART'.
  Cell `$procmux$850' is identical to cell `$procmux$832'.
    Redirecting output \Y: $procmux$850_Y = $procmux$832_Y
    Removing $mux cell `$procmux$850' from module `\test_UART'.
  Cell `$procmux$853' is identical to cell `$procmux$835'.
    Redirecting output \Y: $0$formal$../rtl/test_UART.v:105$17_EN[0:0]$61 = $0$formal$../rtl/test_UART.v:104$16_EN[0:0]$59
    Removing $mux cell `$procmux$853' from module `\test_UART'.
  Cell `$procmux$865' is identical to cell `$procmux$427'.
    Redirecting output \Y: $procmux$865_Y = $procmux$427_Y
    Removing $mux cell `$procmux$865' from module `\test_UART'.
  Cell `$procmux$868' is identical to cell `$procmux$832'.
    Redirecting output \Y: $procmux$868_Y = $procmux$832_Y
    Removing $mux cell `$procmux$868' from module `\test_UART'.
  Cell `$procmux$871' is identical to cell `$procmux$835'.
    Redirecting output \Y: $0$formal$../rtl/test_UART.v:106$18_EN[0:0]$63 = $0$formal$../rtl/test_UART.v:104$16_EN[0:0]$59
    Removing $mux cell `$procmux$871' from module `\test_UART'.
  Cell `$procmux$883' is identical to cell `$procmux$427'.
    Redirecting output \Y: $procmux$883_Y = $procmux$427_Y
    Removing $mux cell `$procmux$883' from module `\test_UART'.
  Cell `$procmux$886' is identical to cell `$procmux$832'.
    Redirecting output \Y: $procmux$886_Y = $procmux$832_Y
    Removing $mux cell `$procmux$886' from module `\test_UART'.
  Cell `$procmux$889' is identical to cell `$procmux$835'.
    Redirecting output \Y: $0$formal$../rtl/test_UART.v:107$19_EN[0:0]$65 = $0$formal$../rtl/test_UART.v:104$16_EN[0:0]$59
    Removing $mux cell `$procmux$889' from module `\test_UART'.
  Cell `$procmux$892' is identical to cell `$procmux$445'.
    Redirecting output \Y: $procmux$892_Y = $procmux$445_Y
    Removing $mux cell `$procmux$892' from module `\test_UART'.
  Cell `$procmux$901' is identical to cell `$procmux$427'.
    Redirecting output \Y: $procmux$901_Y = $procmux$427_Y
    Removing $mux cell `$procmux$901' from module `\test_UART'.
  Cell `$procmux$904' is identical to cell `$procmux$832'.
    Redirecting output \Y: $procmux$904_Y = $procmux$832_Y
    Removing $mux cell `$procmux$904' from module `\test_UART'.
  Cell `$procmux$907' is identical to cell `$procmux$835'.
    Redirecting output \Y: $0$formal$../rtl/test_UART.v:108$20_EN[0:0]$67 = $0$formal$../rtl/test_UART.v:104$16_EN[0:0]$59
    Removing $mux cell `$procmux$907' from module `\test_UART'.
  Cell `$procmux$910' is identical to cell `$procmux$433'.
    Redirecting output \Y: $procmux$910_Y = $procmux$433_Y
    Removing $mux cell `$procmux$910' from module `\test_UART'.
  Cell `$procmux$938' is identical to cell `$procmux$758'.
    Redirecting output \Y: $procmux$938_Y = $procmux$758_Y
    Removing $mux cell `$procmux$938' from module `\test_UART'.
  Cell `$procdff$1018' is identical to cell `$procdff$1016'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:85$10_EN = $formal$../rtl/test_UART.v:84$9_EN
    Removing $dff cell `$procdff$1018' from module `\test_UART'.
  Cell `$procdff$1022' is identical to cell `$procdff$1020'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:90$12_EN = $formal$../rtl/test_UART.v:89$11_EN
    Removing $dff cell `$procdff$1022' from module `\test_UART'.
  Cell `$procdff$1024' is identical to cell `$procdff$1020'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:91$13_EN = $formal$../rtl/test_UART.v:89$11_EN
    Removing $dff cell `$procdff$1024' from module `\test_UART'.
  Cell `$procdff$1028' is identical to cell `$procdff$1026'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:98$15_EN = $formal$../rtl/test_UART.v:97$14_EN
    Removing $dff cell `$procdff$1028' from module `\test_UART'.
  Cell `$procdff$1032' is identical to cell `$procdff$1030'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:105$17_EN = $formal$../rtl/test_UART.v:104$16_EN
    Removing $dff cell `$procdff$1032' from module `\test_UART'.
  Cell `$procdff$1034' is identical to cell `$procdff$1030'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:106$18_EN = $formal$../rtl/test_UART.v:104$16_EN
    Removing $dff cell `$procdff$1034' from module `\test_UART'.
  Cell `$procdff$1036' is identical to cell `$procdff$1030'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:107$19_EN = $formal$../rtl/test_UART.v:104$16_EN
    Removing $dff cell `$procdff$1036' from module `\test_UART'.
  Cell `$procdff$1038' is identical to cell `$procdff$1030'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:108$20_EN = $formal$../rtl/test_UART.v:104$16_EN
    Removing $dff cell `$procdff$1038' from module `\test_UART'.
  Cell `$procdff$987' is identical to cell `$procdff$985'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:137$28_EN = $formal$../rtl/test_UART.v:136$27_EN
    Removing $dff cell `$procdff$987' from module `\test_UART'.
  Cell `$procdff$994' is identical to cell `$procdff$992'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:121$23_EN = $formal$../rtl/test_UART.v:120$22_EN
    Removing $dff cell `$procdff$994' from module `\test_UART'.
  Cell `$procdff$998' is identical to cell `$procdff$996'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:126$25_EN = $formal$../rtl/test_UART.v:125$24_EN
    Removing $dff cell `$procdff$998' from module `\test_UART'.
  Cell `$procdff$1004' is identical to cell `$procdff$1002'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:69$3_EN = $formal$../rtl/test_UART.v:67$2_EN
    Removing $dff cell `$procdff$1004' from module `\test_UART'.
  Cell `$procdff$1006' is identical to cell `$procdff$1002'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:70$4_EN = $formal$../rtl/test_UART.v:67$2_EN
    Removing $dff cell `$procdff$1006' from module `\test_UART'.
  Cell `$procdff$1010' is identical to cell `$procdff$1008'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:78$6_EN = $formal$../rtl/test_UART.v:77$5_EN
    Removing $dff cell `$procdff$1010' from module `\test_UART'.
  Cell `$procdff$1012' is identical to cell `$procdff$1008'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:79$7_EN = $formal$../rtl/test_UART.v:77$5_EN
    Removing $dff cell `$procdff$1012' from module `\test_UART'.
  Cell `$procdff$1014' is identical to cell `$procdff$1016'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:83$8_EN = $formal$../rtl/test_UART.v:84$9_EN
    Removing $dff cell `$procdff$1014' from module `\test_UART'.
Removed a total of 77 cells.

17.6.6. Executing OPT_RMDFF pass (remove dff with constant values).

17.6.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \RxUART..
Finding unused cells or wires in module \Rx_top..
Finding unused cells or wires in module \SIPO_shift_register..
Finding unused cells or wires in module \TxUART..
Finding unused cells or wires in module \Tx_top..
Finding unused cells or wires in module \UART..
Finding unused cells or wires in module \baud_generator..
Finding unused cells or wires in module \check_parity..
Finding unused cells or wires in module \detect_start_bit..
Finding unused cells or wires in module \rx_state..
  removed 1 unused temporary wires.
Finding unused cells or wires in module \sampling_strobe_generator..
Finding unused cells or wires in module \synchronizer..
  removed 2 unused temporary wires.
Finding unused cells or wires in module \test_UART..
  removed 67 unused temporary wires.
  removing redundant init attribute on $formal$../rtl/test_UART.v:105$17_EN.
  removing redundant init attribute on $formal$../rtl/test_UART.v:106$18_EN.
  removing redundant init attribute on $formal$../rtl/test_UART.v:107$19_EN.
  removing redundant init attribute on $formal$../rtl/test_UART.v:108$20_EN.
  removing redundant init attribute on $formal$../rtl/test_UART.v:121$23_EN.
  removing redundant init attribute on $formal$../rtl/test_UART.v:126$25_EN.
  removing redundant init attribute on $formal$../rtl/test_UART.v:137$28_EN.
  removing redundant init attribute on $formal$../rtl/test_UART.v:69$3_EN.
  removing redundant init attribute on $formal$../rtl/test_UART.v:70$4_EN.
  removing redundant init attribute on $formal$../rtl/test_UART.v:78$6_EN.
  removing redundant init attribute on $formal$../rtl/test_UART.v:79$7_EN.
  removing redundant init attribute on $formal$../rtl/test_UART.v:84$9_EN.
  removing redundant init attribute on $formal$../rtl/test_UART.v:85$10_EN.
  removing redundant init attribute on $formal$../rtl/test_UART.v:90$12_EN.
  removing redundant init attribute on $formal$../rtl/test_UART.v:91$13_EN.
  removing redundant init attribute on $formal$../rtl/test_UART.v:98$15_EN.
  removed 16 unused temporary wires.
Removed 0 unused cells and 448 unused wires.

17.6.8. Executing OPT_EXPR pass (perform const folding).

17.6.9. Rerunning OPT passes. (Maybe there is more to do..)

17.6.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \RxUART..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \Rx_top..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \SIPO_shift_register..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
    Root of a mux tree: $procmux$315 (pure)
  Analyzing evaluation results.
Running muxtree optimizer on module \TxUART..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
    Root of a mux tree: $procmux$361 (pure)
    Root of a mux tree: $procmux$370 (pure)
    Root of a mux tree: $procmux$373
    Root of a mux tree: $procmux$382 (pure)
  Analyzing evaluation results.
Running muxtree optimizer on module \Tx_top..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \UART..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \baud_generator..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \check_parity..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
    Root of a mux tree: $procmux$339 (pure)
    Root of a mux tree: $procmux$342 (pure)
    Root of a mux tree: $procmux$345 (pure)
  Analyzing evaluation results.
Running muxtree optimizer on module \detect_start_bit..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
    Root of a mux tree: $procmux$324 (pure)
    Root of a mux tree: $procmux$327 (pure)
    Root of a mux tree: $procmux$330 (pure)
    Root of a mux tree: $procmux$333 (pure)
    Root of a mux tree: $procmux$336 (pure)
  Analyzing evaluation results.
Running muxtree optimizer on module \rx_state..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
    Root of a mux tree: $procmux$358 (pure)
  Analyzing evaluation results.
Running muxtree optimizer on module \sampling_strobe_generator..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
    Root of a mux tree: $procmux$318 (pure)
    Root of a mux tree: $procmux$321 (pure)
  Analyzing evaluation results.
Running muxtree optimizer on module \synchronizer..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \test_UART..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
    Root of a mux tree: $procmux$385 (pure)
    Root of a mux tree: $procmux$388 (pure)
    Root of a mux tree: $procmux$394 (pure)
    Root of a mux tree: $procmux$397 (pure)
    Root of a mux tree: $procmux$400 (pure)
    Root of a mux tree: $procmux$406 (pure)
    Root of a mux tree: $procmux$412 (pure)
    Root of a mux tree: $procmux$424 (pure)
    Root of a mux tree: $procmux$427
    Root of a mux tree: $procmux$430 (pure)
    Root of a mux tree: $procmux$433
    Root of a mux tree: $procmux$436 (pure)
    Root of a mux tree: $procmux$445
    Root of a mux tree: $procmux$448 (pure)
    Root of a mux tree: $procmux$454 (pure)
    Root of a mux tree: $procmux$460 (pure)
    Root of a mux tree: $procmux$472 (pure)
    Root of a mux tree: $procmux$484 (pure)
    Root of a mux tree: $procmux$496 (pure)
    Root of a mux tree: $procmux$508 (pure)
    Root of a mux tree: $procmux$532 (pure)
    Root of a mux tree: $procmux$556 (pure)
    Root of a mux tree: $procmux$571 (pure)
    Root of a mux tree: $procmux$586 (pure)
    Root of a mux tree: $procmux$616 (pure)
    Root of a mux tree: $procmux$646 (pure)
    Root of a mux tree: $procmux$664 (pure)
    Root of a mux tree: $procmux$682 (pure)
    Root of a mux tree: $procmux$718 (pure)
    Root of a mux tree: $procmux$754 (pure)
    Root of a mux tree: $procmux$758
    Root of a mux tree: $procmux$772 (pure)
    Root of a mux tree: $procmux$790 (pure)
    Root of a mux tree: $procmux$826 (pure)
    Root of a mux tree: $procmux$835 (pure)
    Root of a mux tree: $procmux$844 (pure)
    Root of a mux tree: $procmux$862 (pure)
    Root of a mux tree: $procmux$880 (pure)
    Root of a mux tree: $procmux$898 (pure)
    Root of a mux tree: $procmux$916 (pure)
    Root of a mux tree: $procmux$934 (pure)
    Root of a mux tree: $procmux$952 (pure)
  Analyzing evaluation results.
Removed 0 multiplexer ports.

17.6.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \RxUART.
  Optimizing cells in module \Rx_top.
  Optimizing cells in module \SIPO_shift_register.
  Optimizing cells in module \TxUART.
  Optimizing cells in module \Tx_top.
  Optimizing cells in module \UART.
  Optimizing cells in module \baud_generator.
  Optimizing cells in module \check_parity.
  Optimizing cells in module \detect_start_bit.
  Optimizing cells in module \rx_state.
  Optimizing cells in module \sampling_strobe_generator.
  Optimizing cells in module \synchronizer.
  Optimizing cells in module \test_UART.
Performed a total of 0 changes.

17.6.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\RxUART'.
Finding identical cells in module `\Rx_top'.
Finding identical cells in module `\SIPO_shift_register'.
Finding identical cells in module `\TxUART'.
Finding identical cells in module `\Tx_top'.
Finding identical cells in module `\UART'.
Finding identical cells in module `\baud_generator'.
Finding identical cells in module `\check_parity'.
Finding identical cells in module `\detect_start_bit'.
Finding identical cells in module `\rx_state'.
Finding identical cells in module `\sampling_strobe_generator'.
Finding identical cells in module `\synchronizer'.
Finding identical cells in module `\test_UART'.
Removed a total of 0 cells.

17.6.13. Executing OPT_RMDFF pass (remove dff with constant values).

17.6.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \RxUART..
Finding unused cells or wires in module \Rx_top..
Finding unused cells or wires in module \SIPO_shift_register..
Finding unused cells or wires in module \TxUART..
Finding unused cells or wires in module \Tx_top..
Finding unused cells or wires in module \UART..
Finding unused cells or wires in module \baud_generator..
Finding unused cells or wires in module \check_parity..
Finding unused cells or wires in module \detect_start_bit..
Finding unused cells or wires in module \rx_state..
Finding unused cells or wires in module \sampling_strobe_generator..
Finding unused cells or wires in module \synchronizer..
Finding unused cells or wires in module \test_UART..
Removed 0 unused cells and 448 unused wires.

17.6.15. Executing OPT_EXPR pass (perform const folding).

17.6.16. Finished OPT passes. (There is nothing left to do.)

17.7. Executing WREDUCE pass (reducing word size of cells).
Removed top 31 bits (of 32) from port B of cell baud_generator.$add$../rtl/Tx/baud_generator.v:24$221 ($add).
Removed top 29 bits (of 32) from port Y of cell baud_generator.$add$../rtl/Tx/baud_generator.v:24$221 ($add).
Removed cell detect_start_bit.$procmux$327 ($mux).
Removed top 25 bits (of 32) from port B of cell detect_start_bit.$ge$../rtl/Rx/detect_start_bit.v:32$299 ($ge).
Removed top 31 bits (of 32) from port B of cell detect_start_bit.$add$../rtl/Rx/detect_start_bit.v:39$301 ($add).
Removed top 25 bits (of 32) from port Y of cell detect_start_bit.$add$../rtl/Rx/detect_start_bit.v:39$301 ($add).
Removed top 25 bits (of 32) from wire detect_start_bit.$add$../rtl/Rx/detect_start_bit.v:39$301_Y.
Removed top 3 bits (of 4) from port B of cell rx_state.$procmux$353_CMP0 ($eq).
Removed top 1 bits (of 4) from port B of cell rx_state.$procmux$352_CMP5 ($eq).
Removed top 1 bits (of 4) from port B of cell rx_state.$procmux$352_CMP4 ($eq).
Removed top 1 bits (of 4) from port B of cell rx_state.$procmux$352_CMP3 ($eq).
Removed top 1 bits (of 4) from port B of cell rx_state.$procmux$352_CMP2 ($eq).
Removed top 2 bits (of 4) from port B of cell rx_state.$procmux$352_CMP1 ($eq).
Removed top 2 bits (of 4) from port B of cell rx_state.$procmux$352_CMP0 ($eq).
Removed top 2 bits (of 4) from port B of cell rx_state.$ge$../rtl/Rx/rx_state.v:37$278 ($ge).
Removed top 3 bits (of 4) from mux cell rx_state.$ternary$../rtl/Rx/rx_state.v:48$282 ($mux).
Removed top 3 bits (of 4) from wire rx_state.$ternary$../rtl/Rx/rx_state.v:48$282_Y.
Removed top 31 bits (of 32) from port B of cell sampling_strobe_generator.$add$../rtl/Rx/sampling_strobe_generator.v:19$261 ($add).
Removed top 29 bits (of 32) from port Y of cell sampling_strobe_generator.$add$../rtl/Rx/sampling_strobe_generator.v:19$261 ($add).
Removed top 31 bits (of 32) from port Y of cell sampling_strobe_generator.$and$../rtl/Rx/sampling_strobe_generator.v:34$268 ($and).
Removed top 29 bits (of 32) from wire sampling_strobe_generator.$add$../rtl/Rx/sampling_strobe_generator.v:19$261_Y.
Removed top 31 bits (of 32) from wire sampling_strobe_generator.$and$../rtl/Rx/sampling_strobe_generator.v:34$268_Y.
Removed top 31 bits (of 32) from port B of cell test_UART.$add$../rtl/test_UART.v:74$73 ($add).
Removed top 25 bits (of 32) from port Y of cell test_UART.$add$../rtl/test_UART.v:74$73 ($add).
Removed top 3 bits (of 7) from port B of cell test_UART.$eq$../rtl/test_UART.v:76$74 ($eq).
Removed top 25 bits (of 32) from port B of cell test_UART.$lt$../rtl/test_UART.v:137$120 ($lt).
Removed cell test_UART.$procmux$388 ($mux).
Removed cell test_UART.$procmux$394 ($mux).
Removed cell test_UART.$procmux$400 ($mux).
Removed cell test_UART.$procmux$409 ($mux).
Removed cell test_UART.$procmux$412 ($mux).
Removed cell test_UART.$procmux$421 ($mux).
Removed cell test_UART.$procmux$424 ($mux).
Removed cell test_UART.$procmux$433 ($mux).
Removed cell test_UART.$procmux$436 ($mux).
Removed cell test_UART.$procmux$445 ($mux).
Removed cell test_UART.$procmux$448 ($mux).
Removed cell test_UART.$procmux$457 ($mux).
Removed cell test_UART.$procmux$460 ($mux).
Removed cell test_UART.$procmux$469 ($mux).
Removed cell test_UART.$procmux$472 ($mux).
Removed cell test_UART.$procmux$481 ($mux).
Removed cell test_UART.$procmux$484 ($mux).
Removed cell test_UART.$procmux$500 ($mux).
Removed cell test_UART.$procmux$502 ($mux).
Removed cell test_UART.$procmux$505 ($mux).
Removed cell test_UART.$procmux$508 ($mux).
Removed cell test_UART.$procmux$524 ($mux).
Removed cell test_UART.$procmux$526 ($mux).
Removed cell test_UART.$procmux$529 ($mux).
Removed cell test_UART.$procmux$532 ($mux).
Removed cell test_UART.$procmux$548 ($mux).
Removed cell test_UART.$procmux$550 ($mux).
Removed cell test_UART.$procmux$553 ($mux).
Removed cell test_UART.$procmux$556 ($mux).
Removed cell test_UART.$procmux$575 ($mux).
Removed cell test_UART.$procmux$578 ($mux).
Removed cell test_UART.$procmux$580 ($mux).
Removed cell test_UART.$procmux$583 ($mux).
Removed cell test_UART.$procmux$586 ($mux).
Removed cell test_UART.$procmux$605 ($mux).
Removed cell test_UART.$procmux$608 ($mux).
Removed cell test_UART.$procmux$610 ($mux).
Removed cell test_UART.$procmux$613 ($mux).
Removed cell test_UART.$procmux$616 ($mux).
Removed cell test_UART.$procmux$635 ($mux).
Removed cell test_UART.$procmux$638 ($mux).
Removed cell test_UART.$procmux$640 ($mux).
Removed cell test_UART.$procmux$643 ($mux).
Removed cell test_UART.$procmux$646 ($mux).
Removed cell test_UART.$procmux$668 ($mux).
Removed cell test_UART.$procmux$671 ($mux).
Removed cell test_UART.$procmux$674 ($mux).
Removed cell test_UART.$procmux$676 ($mux).
Removed cell test_UART.$procmux$679 ($mux).
Removed cell test_UART.$procmux$682 ($mux).
Removed cell test_UART.$procmux$704 ($mux).
Removed cell test_UART.$procmux$707 ($mux).
Removed cell test_UART.$procmux$710 ($mux).
Removed cell test_UART.$procmux$712 ($mux).
Removed cell test_UART.$procmux$715 ($mux).
Removed cell test_UART.$procmux$718 ($mux).
Removed cell test_UART.$procmux$740 ($mux).
Removed cell test_UART.$procmux$743 ($mux).
Removed cell test_UART.$procmux$746 ($mux).
Removed cell test_UART.$procmux$748 ($mux).
Removed cell test_UART.$procmux$751 ($mux).
Removed cell test_UART.$procmux$754 ($mux).
Removed cell test_UART.$procmux$776 ($mux).
Removed cell test_UART.$procmux$779 ($mux).
Removed cell test_UART.$procmux$782 ($mux).
Removed cell test_UART.$procmux$784 ($mux).
Removed cell test_UART.$procmux$787 ($mux).
Removed cell test_UART.$procmux$790 ($mux).
Removed cell test_UART.$procmux$812 ($mux).
Removed cell test_UART.$procmux$815 ($mux).
Removed cell test_UART.$procmux$818 ($mux).
Removed cell test_UART.$procmux$820 ($mux).
Removed cell test_UART.$procmux$823 ($mux).
Removed cell test_UART.$procmux$826 ($mux).
Removed cell test_UART.$procmux$838 ($mux).
Removed cell test_UART.$procmux$841 ($mux).
Removed cell test_UART.$procmux$844 ($mux).
Removed cell test_UART.$procmux$856 ($mux).
Removed cell test_UART.$procmux$859 ($mux).
Removed cell test_UART.$procmux$862 ($mux).
Removed cell test_UART.$procmux$874 ($mux).
Removed cell test_UART.$procmux$877 ($mux).
Removed cell test_UART.$procmux$880 ($mux).
Removed cell test_UART.$procmux$895 ($mux).
Removed cell test_UART.$procmux$898 ($mux).
Removed cell test_UART.$procmux$913 ($mux).
Removed cell test_UART.$procmux$916 ($mux).
Removed top 25 bits (of 32) from wire test_UART.$add$../rtl/test_UART.v:74$73_Y.

17.8. Executing MEMORY_DFF pass (merging $dff cells to $memrd and $memwr).

17.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \RxUART..
Finding unused cells or wires in module \Rx_top..
Finding unused cells or wires in module \SIPO_shift_register..
Finding unused cells or wires in module \TxUART..
Finding unused cells or wires in module \Tx_top..
Finding unused cells or wires in module \UART..
Finding unused cells or wires in module \baud_generator..
  removed 1 unused temporary wires.
Finding unused cells or wires in module \check_parity..
Finding unused cells or wires in module \detect_start_bit..
  removed 2 unused temporary wires.
Finding unused cells or wires in module \rx_state..
  removed 1 unused temporary wires.
Finding unused cells or wires in module \sampling_strobe_generator..
  removed 2 unused temporary wires.
Finding unused cells or wires in module \synchronizer..
Finding unused cells or wires in module \test_UART..
  removed 88 unused temporary wires.
Removed 0 unused cells and 542 unused wires.

17.10. Executing MEMORY_COLLECT pass (generating $mem cells).

17.11. Executing OPT pass (performing simple optimizations).

17.11.1. Executing OPT_EXPR pass (perform const folding).

17.11.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\RxUART'.
Finding identical cells in module `\Rx_top'.
Finding identical cells in module `\SIPO_shift_register'.
Finding identical cells in module `\TxUART'.
Finding identical cells in module `\Tx_top'.
Finding identical cells in module `\UART'.
Finding identical cells in module `\baud_generator'.
Finding identical cells in module `\check_parity'.
Finding identical cells in module `\detect_start_bit'.
Finding identical cells in module `\rx_state'.
Finding identical cells in module `\sampling_strobe_generator'.
Finding identical cells in module `\synchronizer'.
Finding identical cells in module `\test_UART'.
  Cell `$procdff$1007' is identical to cell `$procdff$1003'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:77$5_CHECK = $formal$../rtl/test_UART.v:69$3_CHECK
    Removing $dff cell `$procdff$1007' from module `\test_UART'.
  Cell `$procdff$1013' is identical to cell `$procdff$1003'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:83$8_CHECK = $formal$../rtl/test_UART.v:69$3_CHECK
    Removing $dff cell `$procdff$1013' from module `\test_UART'.
  Cell `$procdff$1015' is identical to cell `$procdff$1005'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:84$9_CHECK = $formal$../rtl/test_UART.v:70$4_CHECK
    Removing $dff cell `$procdff$1015' from module `\test_UART'.
  Cell `$procdff$1017' is identical to cell `$procdff$1011'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:85$10_CHECK = $formal$../rtl/test_UART.v:79$7_CHECK
    Removing $dff cell `$procdff$1017' from module `\test_UART'.
  Cell `$procdff$1023' is identical to cell `$procdff$1005'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:91$13_CHECK = $formal$../rtl/test_UART.v:70$4_CHECK
    Removing $dff cell `$procdff$1023' from module `\test_UART'.
  Cell `$procdff$1025' is identical to cell `$procdff$1003'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:97$14_CHECK = $formal$../rtl/test_UART.v:69$3_CHECK
    Removing $dff cell `$procdff$1025' from module `\test_UART'.
  Cell `$procdff$1027' is identical to cell `$procdff$1011'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:98$15_CHECK = $formal$../rtl/test_UART.v:79$7_CHECK
    Removing $dff cell `$procdff$1027' from module `\test_UART'.
  Cell `$procdff$1029' is identical to cell `$procdff$1001'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:104$16_CHECK = $formal$../rtl/test_UART.v:67$2_CHECK
    Removing $dff cell `$procdff$1029' from module `\test_UART'.
  Cell `$procdff$1033' is identical to cell `$procdff$1003'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:106$18_CHECK = $formal$../rtl/test_UART.v:69$3_CHECK
    Removing $dff cell `$procdff$1033' from module `\test_UART'.
  Cell `$procdff$1035' is identical to cell `$procdff$1005'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:107$19_CHECK = $formal$../rtl/test_UART.v:70$4_CHECK
    Removing $dff cell `$procdff$1035' from module `\test_UART'.
  Cell `$procdff$993' is identical to cell `$procdff$1011'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:121$23_CHECK = $formal$../rtl/test_UART.v:79$7_CHECK
    Removing $dff cell `$procdff$993' from module `\test_UART'.
  Cell `$procdff$995' is identical to cell `$procdff$1037'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:125$24_CHECK = $formal$../rtl/test_UART.v:108$20_CHECK
    Removing $dff cell `$procdff$995' from module `\test_UART'.
  Cell `$procdff$997' is identical to cell `$procdff$1005'.
    Redirecting output \Q: $formal$../rtl/test_UART.v:126$25_CHECK = $formal$../rtl/test_UART.v:70$4_CHECK
    Removing $dff cell `$procdff$997' from module `\test_UART'.
Removed a total of 13 cells.

17.11.3. Executing OPT_RMDFF pass (remove dff with constant values).

17.11.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \RxUART..
Finding unused cells or wires in module \Rx_top..
Finding unused cells or wires in module \SIPO_shift_register..
Finding unused cells or wires in module \TxUART..
Finding unused cells or wires in module \Tx_top..
Finding unused cells or wires in module \UART..
Finding unused cells or wires in module \baud_generator..
Finding unused cells or wires in module \check_parity..
Finding unused cells or wires in module \detect_start_bit..
Finding unused cells or wires in module \rx_state..
Finding unused cells or wires in module \sampling_strobe_generator..
Finding unused cells or wires in module \synchronizer..
Finding unused cells or wires in module \test_UART..
  removed 13 unused temporary wires.
Removed 0 unused cells and 555 unused wires.

17.11.5. Finished fast OPT passes.

17.12. Printing statistics.

=== RxUART ===

   Number of wires:                 10
   Number of wire bits:             20
   Number of public wires:          10
   Number of public wire bits:      20
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  4
     SIPO_shift_register             1
     detect_start_bit                1
     rx_state                        1
     sampling_strobe_generator       1

=== Rx_top ===

   Number of wires:                 10
   Number of wire bits:             20
   Number of public wires:          10
   Number of public wire bits:      20
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  3
     RxUART                          1
     check_parity                    1
     synchronizer                    1

=== SIPO_shift_register ===

   Number of wires:                  5
   Number of wire bits:             19
   Number of public wires:           4
   Number of public wire bits:      11
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  2
     $dff                            1
     $mux                            1

=== TxUART ===

   Number of wires:                 23
   Number of wire bits:             81
   Number of public wires:           8
   Number of public wire bits:      26
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 18
     $and                            1
     $dff                            3
     $logic_and                      1
     $logic_not                      2
     $mux                            8
     $or                             1
     $reduce_and                     1
     $reduce_bool                    1

=== Tx_top ===

   Number of wires:                  8
   Number of wire bits:             15
   Number of public wires:           8
   Number of public wire bits:      15
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  3
     $reduce_xor                     1
     TxUART                          1
     baud_generator                  1

=== UART ===

   Number of wires:                 11
   Number of wire bits:             28
   Number of public wires:          11
   Number of public wire bits:      28
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  2
     Rx_top                          1
     Tx_top                          1

=== baud_generator ===

   Number of wires:                  6
   Number of wire bits:             10
   Number of public wires:           4
   Number of public wire bits:       6
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  4
     $add                            1
     $dff                            2
     $eq                             1

=== check_parity ===

   Number of wires:                 12
   Number of wire bits:             19
   Number of public wires:           7
   Number of public wire bits:      14
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  8
     $dff                            3
     $mux                            3
     $ne                             1
     $reduce_xor                     1

=== detect_start_bit ===

   Number of wires:                 20
   Number of wire bits:             38
   Number of public wires:           6
   Number of public wire bits:      12
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 19
     $add                            1
     $assert                         1
     $dff                            5
     $ge                             1
     $logic_and                      3
     $logic_not                      3
     $mux                            4
     $not                            1

=== rx_state ===

   Number of wires:                 25
   Number of wire bits:             50
   Number of public wires:           8
   Number of public wire bits:      11
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 29
     $add                            1
     $assume                         1
     $dff                            6
     $eq                            11
     $ge                             1
     $le                             2
     $logic_and                      1
     $logic_not                      1
     $mux                            3
     $pmux                           1
     $reduce_or                      1

=== sampling_strobe_generator ===

   Number of wires:                 13
   Number of wire bits:             19
   Number of public wires:           4
   Number of public wire bits:       6
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 12
     $add                            1
     $and                            1
     $assert                         1
     $dff                            5
     $eq                             1
     $logic_not                      1
     $mux                            2

=== synchronizer ===

   Number of wires:                  6
   Number of wire bits:              6
   Number of public wires:           5
   Number of public wire bits:       5
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  7
     $assume                         3
     $dff                            3
     $initstate                      1

=== test_UART ===

   Number of wires:                 99
   Number of wire bits:            171
   Number of public wires:          13
   Number of public wire bits:      36
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                116
     $add                            1
     $assert                        25
     $assume                         2
     $dff                           28
     $eq                             6
     $logic_and                      1
     $logic_not                      4
     $lt                             1
     $mux                           42
     $not                            4
     $or                             1
     UART                            1

=== design hierarchy ===

   test_UART                         1
     UART                            1
       Rx_top                        1
         RxUART                      1
           SIPO_shift_register       1
           detect_start_bit          1
           rx_state                  1
           sampling_strobe_generator      1
         check_parity                1
         synchronizer                1
       Tx_top                        1
         TxUART                      1
         baud_generator              1

   Number of wires:                248
   Number of wire bits:            496
   Number of public wires:          98
   Number of public wire bits:     210
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                215
     $add                            5
     $and                            2
     $assert                        27
     $assume                         6
     $dff                           56
     $eq                            19
     $ge                             2
     $initstate                      1
     $le                             2
     $logic_and                      6
     $logic_not                     11
     $lt                             1
     $mux                           63
     $ne                             1
     $not                            5
     $or                             2
     $pmux                           1
     $reduce_and                     1
     $reduce_bool                    1
     $reduce_or                      1
     $reduce_xor                     2

17.13. Executing CHECK pass (checking for obvious problems).
checking module RxUART..
checking module Rx_top..
checking module SIPO_shift_register..
checking module TxUART..
checking module Tx_top..
checking module UART..
checking module baud_generator..
checking module check_parity..
checking module detect_start_bit..
checking module rx_state..
checking module sampling_strobe_generator..
checking module synchronizer..
checking module test_UART..
found and reported 0 problems.

-- Running command `write_smt2 -wires UART.smt2' --

18. Executing SMT2 backend.
Creating SMT-LIBv2 representation of module baud_generator.
Creating SMT-LIBv2 representation of module TxUART.
Creating SMT-LIBv2 representation of module synchronizer.
Creating SMT-LIBv2 representation of module check_parity.
Creating SMT-LIBv2 representation of module rx_state.
Creating SMT-LIBv2 representation of module detect_start_bit.
Creating SMT-LIBv2 representation of module sampling_strobe_generator.
Creating SMT-LIBv2 representation of module SIPO_shift_register.
Creating SMT-LIBv2 representation of module Tx_top.
Creating SMT-LIBv2 representation of module RxUART.
Creating SMT-LIBv2 representation of module Rx_top.
Creating SMT-LIBv2 representation of module UART.
Creating SMT-LIBv2 representation of module test_UART.

End of script. Logfile hash: 60d930defc
CPU: user 0.22s system 0.00s, MEM: 39.62 MB total, 10.39 MB resident
Yosys 0.7+386 (git sha1 ca2adc30, gcc 7.2.1 -march=x86-64 -mtune=generic -O2 -fstack-protector-strong -fPIC -Os)
Time spent: 19% 5x opt_expr (0 sec), 15% 4x opt_merge (0 sec), ...
